<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>栈</title>
      <link href="2022/02/28/zhan/"/>
      <url>2022/02/28/zhan/</url>
      
        <content type="html"><![CDATA[<h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><p>通过数组的学习，我们复习了数组的一些API，这些在JS中是很基础的。我会从这一节开始，将一些函数整理到自己的<a href="https://github.com/dreamITGirl/JS-Data-structure">github</a>库中，以便大家查看及学习。</p><p>本次内容主要包括</p><ul><li>栈数据结构</li><li>向栈中增加元素</li><li>删除栈中的元素</li><li>如何使用Stack类</li><li>十进制转二进制</li></ul><h4 id="1-栈数据结构"><a href="#1-栈数据结构" class="headerlink" title="1. 栈数据结构"></a>1. 栈数据结构</h4><p>栈是一种遵循后进先出(LIFO = last in first out)原则,是一种用来表示元素的集合，主要操作有两种，<code>push</code> 和 <code>pop</code></p><p><code>push</code> 是向栈的顶部(尾部)中增加一个元素<br><code>pop</code> 是移除栈中最顶端(尾部)的元素 </p><p><img src="https://camo.githubusercontent.com/7163784baed9e988949a1dfbf1e749eac91ea38cd1f738ec5094469f22242675/68747470733a2f2f75706c6f61642e77696b696d656469612e6f72672f77696b6970656469612f636f6d6d6f6e732f622f62342f4c69666f5f737461636b2e706e67" alt="如图所示"></p><h4 id="2-创建一个基于数组的栈"><a href="#2-创建一个基于数组的栈" class="headerlink" title="2. 创建一个基于数组的栈"></a>2. 创建一个基于数组的栈</h4><p>根据栈遵循的LIFO的原则，我们需要对元素的插入和删除功能做一些限制，我们要为栈声明以下几种方法</p><ul><li><code>push(elements)</code>：向栈顶添加一个或几个元素到栈顶</li><li><code>pop()</code> ： 移除栈顶的元素，返回值为移除的元素</li><li><code>peek()</code> : 返回栈顶的元素，不对它做任何处理（只是返回这一值）</li><li><code>isEmpty()</code>: 判断栈是否为空</li><li><code>clear()</code> : 清空栈中的元素</li><li><code>size()</code> : 返回栈中元素的个数，类似于数组的<code>length</code></li></ul><pre class="line-numbers language-none"><code class="language-none">class Stack &#123;    constructor()&#123;        this.items &#x3D; [] &#x2F;&#x2F; 我们可以用数组来保存栈中的数据    &#125;    push(elem)&#123;        this.items.push(elem) &#x2F;&#x2F; 通过上面的图，我们可以使用数组中的push方法将元素推到栈顶    &#125;    pop()&#123;       return this.items.pop()    &#125;    peek()&#123;      return this.items[this.items.length - 1]      &#125;    isEmpty()&#123;        return this.items.length &#x3D;&#x3D;&#x3D; 0    &#125;    clear()&#123;        this.items &#x3D; []    &#125;    size()&#123;        return this.items.length     &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>接下来我们使用一下我们封装的<code>Stack</code>类</p><pre class="line-numbers language-none"><code class="language-none">var stack &#x3D; new Stack()console.log(stack.isEmpty()) &#x2F;&#x2F; truestack.push(9)stack.push(8)console.log(stack.size()) &#x2F;&#x2F; 2console.log(stack) &#x2F;&#x2F; Stack &#123; items: [ 9, 8 ] &#125;stack.push(7)stack.push(6)console.log(stack) &#x2F;&#x2F; Stack &#123; items: [ 9, 8, 7, 6] &#125;console.log(stack.peek()) &#x2F;&#x2F; 6console.log(stack.pop()) &#x2F;&#x2F; 6console.log(stack) &#x2F;&#x2F; Stack &#123; items: [ 9, 8, 7 ] &#125;stack.clear()console.log(stack) &#x2F;&#x2F; Stack &#123; items: [] &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="3-如何使用Stack类"><a href="#3-如何使用Stack类" class="headerlink" title="3. 如何使用Stack类"></a>3. 如何使用Stack类</h4><p>在我们使用数组中的方法是，大部分的API的时间复杂度是O(n)</p><p>上述的代码中我们只是在栈顶去推入一个元素。我们现在需要改进一下我们的例子,在<code>Stack</code>的构造函数中增加<code>count</code>的属性，这样可以在栈的任何位置插入元素,下面的代码只拿出来修改的部分</p><pre class="line-numbers language-none"><code class="language-none">constructor()&#123;    this.items &#x3D; [] &#x2F;&#x2F; 我们可以用数组来保存栈中的数据    this.count &#x3D; 0&#125;push(elem)&#123;   &#x2F;&#x2F; this.items.push(elem) &#x2F;&#x2F; 通过上面的图，我们可以使用数组中的push方法将元素推到栈顶   this.items[this.count] &#x3D; elem   this.count ++&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们测试之后</p><pre class="line-numbers language-none"><code class="language-none">var stack &#x3D; new Stack()console.log(stack) &#x2F;&#x2F; Stack &#123; items: [], count: 0 &#125;stack.push(9)stack.push(8)console.log(stack) &#x2F;&#x2F; Stack &#123; items: [ 9, 8 ], count: 2 &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>同样的思路，我们将其他方法也修改一下，升级后的<code>Stack</code>类如下</p><pre class="line-numbers language-none"><code class="language-none">class Stack &#123;    constructor()&#123;        this.items &#x3D; [] &#x2F;&#x2F; 我们可以用数组来保存栈中的数据        this.count &#x3D; 0    &#125;    push(elem)&#123;        this.items[this.count] &#x3D; elem        this.count++        &#x2F;&#x2F; this.items.push(elem)    &#125;    pop()&#123;        if (this.isEmpty()) &#123;            return undefined         &#125;        const item &#x3D; this.items[this.count-1]        this.count--        return item    &#x2F;&#x2F;    return this.items.pop()    &#125;    peek()&#123;        if (this.isEmpty()) &#123;           return undefined         &#125;        return this.items[this.count - 1]      &#125;    isEmpty()&#123;        return this.count &#x3D;&#x3D;&#x3D; 0    &#125;    clear()&#123;        this.items &#x3D; []        this.count &#x3D; 0    &#125;    size()&#123;        return this.count    &#125;    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>接下来，我们在<code>Stack</code>类中增加一个<code>toString()</code>的方法，将数组结构转化为字符串</p><pre class="line-numbers language-none"><code class="language-none">toString()&#123;    if (this.isEmpty()) &#123;        return &#39;&#39;    &#125;    let objString &#x3D; &#96;$&#123;this.items[0]&#125;&#96;    for (let i &#x3D; 1; i &lt; this.items.length; i++) &#123;        objString &#x3D; &#96;$&#123;objString&#125;,$&#123;this.items[i]&#125;&#96;    &#125;    return objString&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">var stack &#x3D; new Stack()stack.push(9)stack.push(8)stack.push(7)stack.push(6)console.log(stack.toString()) &#x2F;&#x2F; 9,8,7,6<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="4-用栈解决问题"><a href="#4-用栈解决问题" class="headerlink" title="4. 用栈解决问题"></a>4. 用栈解决问题</h4><p>我们在回溯算法问题中，栈可以用来存储访问过的任务或者路径、撤销操作。又或者在前端访问页面时的历史记录就是一个栈，我们这里介绍的是十进制转化为二进制，以及任意进制转换的算法</p><p><img src="https://s2.loli.net/2022/02/28/6lvSIfqXbxD1Pen.png" alt="进制转换.png"></p><p>通过上述的图我们可以看到十进制转化为二进制的过程</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F;  进制转换函数function decimalToBinary(decNumber) &#123;    const remStack &#x3D; new Stack()    let number &#x3D; decNumber    let rem;    let binaryString &#x3D; &#39;&#39;    while (number &gt; 0) &#123;        rem &#x3D; Math.floor(number % 2)        remStack.push(rem)        number &#x3D; Math.floor(number &#x2F; 2)    &#125;    console.log(remStack,&#39;remStack&#39;,remStack.isEmpty())    while (!remStack.isEmpty()) &#123;        binaryString +&#x3D; remStack.pop().toString()    &#125;    return binaryString&#125;console.log(decimalToBinary(10)) &#x2F;&#x2F; 1010<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>接下来我们可以对这个函数进行改造一下，让它可以实现任意进制转换</p><pre class="line-numbers language-none"><code class="language-none">function baseConvert(decNumber,base) &#123;    const remStack &#x3D; new Stack()    const digits &#x3D; &#39;0123456789ABCDEFGHIGKLMNOPQRSTUVWXYZ&#39;    let number &#x3D; decNumber    let rem ;    let binaryString &#x3D; &#39;&#39;    if (!(base &gt;&#x3D; 2 &amp;&amp; base &lt;&#x3D; 36)) &#123;        return &#39;&#39;    &#125;    while (number &gt; 0) &#123;        rem &#x3D; Math.floor(number % base)        remStack.push(rem)        number &#x3D; Math.floor(number &#x2F; base)    &#125;    while (!remStack.isEmpty()) &#123;        binaryString +&#x3D; digits[remStack.pop()]    &#125;        return binaryString&#125;console.log(baseConvert(100345,3)) &#x2F;&#x2F; 12002122111<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>下一篇文章是关于队列的，队列则和我们生活中的排队是一样的，遵循先进先出，后进后出的原则。这也是和栈最重要的区别</strong></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数组</title>
      <link href="2022/02/24/shu-zu/"/>
      <url>2022/02/24/shu-zu/</url>
      
        <content type="html"><![CDATA[<p>###数组</p><p>JS中有很多关于数组的API，之所以增加关于数组的介绍，是为了方便后面的知识。</p><p> <strong>创建数组</strong></p><pre class="line-numbers language-none"><code class="language-none">let arr &#x3D; new Array() &#x2F;&#x2F; 通过new的这种方式创建let arrOne &#x3D; [] <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>这两种是常用的创建数组的方式</p><p><strong>访问数组</strong></p><p>我们在访问数组时，通常采用遍历的方式去查找数组中的某个值，如果知道该值在数组中的位置，可以直接通过<code>arr[index]</code>下标值的方式获取。</p><pre class="line-numbers language-none"><code class="language-none">const a &#x3D; arr[0] &#x2F;&#x2F; 在知道index坐标的情况下<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>还可以通过<code>forEach</code>、<code>map</code> 、<code>filter</code>等方式进行访问数组</p><p><strong>插入值</strong></p><p>数组中有插入值的API，<code>push</code> 和 <code>shift</code>两种，<code>push</code>是从数组尾部推入值，<code>shift</code> 是往数组头部插入值，如果在数组某一位置插入值的话，需要用到遍历的方式。</p><pre class="line-numbers language-none"><code class="language-none">class Array &#123;  constructor()&#123;    this.arr &#x3D; []    this.length &#x3D; this.arr.length  &#125;  push(value)&#123;      this.arr[this.length] &#x3D; value      this.length +&#x3D; 1      return this.arr  &#125;  shift(value)&#123;     this.arr &#x3D; [value,...this.arr]     this.length +&#x3D; 1     return this.arr  &#125;  insertValue(value,index)&#123;      if(this.length &#x3D;&#x3D; 0)&#123;          this.arr[index] &#x3D; value          this.length +&#x3D; 1        &#125;      if(this.length &gt; 0)&#123;          if(index &gt; this.length)&#123;            this.length &#x3D; index + 1            this.arr[index] &#x3D; value          &#125; else &#123;             this.length +&#x3D; 1              for (let i &#x3D; this.length - 1; i &gt;&#x3D; index; i--) &#123;                this.arr[i] &#x3D; this.arr[i-1]                  if (i&#x3D;&#x3D; index) &#123;                    this.arr[i] &#x3D; value                 &#125;              &#125;          &#125;      &#125;  &#125;&#125;&#x2F;&#x2F; 测试一下var arr &#x3D; new Arr()arr.push(1)arr.shift(2)arr.insertValue(3,5)arr.insertValue(4,0)arr.insertValue(5,3)arr.insertValue(6,2)arr.insertValue(7,4)arr.insertValue(8,4)console.log(arr); &#x2F;** Array &#123;arr: [    4,         2,    6,         1,    8,         7,    5,         undefined,    undefined, undefined,    3  ],  length: 11&#125;**&#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>删除值</strong></p><p>接下来看数组中删除某个值，数组中常见的删除方法有<code>pop()</code> 、 <code>unshift()</code>两种方法 ，<code>pop()</code>是数组删除最后一个元素，<code>unshift()</code>是数组删除第一个元素,还是在我们创建的Array的类中写一下方法</p><pre class="line-numbers language-none"><code class="language-none">pop()&#123;    const lastValue &#x3D; this.arr[this.length - 1]    this.arr.splice(this.length-1,1)    this.length -&#x3D; 1    return lastValue&#125;unshift()&#123;    const firstValue &#x3D; this.arr[0]    this.arr.splice(0,1)    this.length -&#x3D; 1    return firstValue&#125;deleteValue(index)&#123; &#x2F;&#x2F; 删除某个位置的值    if(index &#x3D;&#x3D;&#x3D; 0)&#123;        this.unshift()    &#125; else if(index &#x3D;&#x3D; this.length - 1)&#123;        this.pop()    &#125; else &#123;        const delVal &#x3D; this.arr[index]        this.arr.splice(index,1)        this.length -&#x3D; 1        return delVal    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>测试一下删除的结果</p><pre class="line-numbers language-none"><code class="language-none">arr.pop() &#x2F;** Array &#123;  arr: [ 4, 2, 6, 1, 8, 7, 5, undefined, undefined, undefined ],  length: 10&#125; **&#x2F;arr.unshift()&#x2F;**Array &#123;  arr: [ 2, 6, 1, 8, 7, 5, undefined, undefined, undefined ],  length: 9&#125;**&#x2F;arr.deleteValue(2)console.log(arr);&#x2F;**Array &#123;  arr: [ 2, 6, 8, 7, 5, undefined, undefined, undefined ],  length: 8&#125;**&#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>JS数组方法参考</strong></p><ol><li>数组的合并</li></ol><p><code>caoncat()</code> 可以将两个数组合并，也可以使用ES6中的解构方法</p><pre class="line-numbers language-none"><code class="language-none">const arr &#x3D; [1,2,3].concat(4,5,6) &#x2F;&#x2F; [ 1, 2, 3, 4, 5, 6 ]const arr1 &#x3D; [7,8,9,...arr] &#x2F;&#x2F; [7, 8, 9, 1, 2, 3, 4, 5, 6]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ol start="2"><li>迭代器函数</li></ol><p><code>forEach()</code> 、<code>map()</code> 、 <code>every()</code> 、 <code>some()</code> 、<code>filter()</code> 、<code>reduce()</code> 这几种方法都是迭代器函数</p><pre class="line-numbers language-none"><code class="language-none">var arr &#x3D; [1,2,3,4,5,6]arr.forEach((item,index) &#x3D;&gt; &#123;   arr[index] &#x3D; 2 * item&#125;)console.log(arr) &#x2F;&#x2F; [ 2, 4, 6, 8, 10, 12 ]&#x2F;&#x2F; map 返回新的数组const arr1 &#x3D; arr.map((item,index) &#x3D;&gt;&#123;    return arr[index] &#x3D; item + index&#125;)console.log(arr1,&#39;arr1) &#x2F;&#x2F; [ 1, 3, 5, 7, 9, 11 ]&#x2F;&#x2F; every 返回为true的数组const arr2 &#x3D; arr.every((item) &#x3D;&gt; &#123;    return item % 2 &#x3D;&#x3D; 0&#125;)&#x2F;&#x2F; 如果每个值都满足条件，则返回true,否则，返回falseconst arr3 &#x3D; arr.some((item) &#x3D;&gt; &#123;    return item % 2 &#x3D;&#x3D; 0&#125;)&#x2F;&#x2F; 如果有一个满足，则返回true，这是和every不同的地方const arr4 &#x3D; arr.filter((item) &#x3D;&gt; &#123;    return item % 2 &#x3D;&#x3D;&#x3D; 0&#125;)&#x2F;&#x2F; [ 2, 4, 6 ]&#x2F;&#x2F; filter()的方法返回数组中满足条件的数据，返回新的数组const arr5 &#x3D; arr.reduce((prev,cur) &#x3D;&gt; &#123;    return cur &#x3D; Number(cur) + Number(prev)&#125;)&#x2F;&#x2F; 21&#x2F;&#x2F; reduce是累加器，返回来的是数组各项的<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="3"><li>ES6中的常用的新的方法</li></ol><p><code>for...of..</code> 、<code>for...in...</code> 、<code>Array.from()</code> 、 <code>findIndex()</code> 、 <code>entries()</code> 、<code>keys()</code> 、<code>values()</code>、<code>includes()</code> 等方法，此处不再一一赘述。</p><ol start="4"><li>数组排序</li></ol><p><code>sort(cb)</code>一般是数组排序常用的API。我们接下来在我们的<code>Array</code>类中封装一个比较的函数</p><pre class="line-numbers language-none"><code class="language-none">sort()&#123;    if (this.length &#x3D;&#x3D; 0) &#123;        return []    &#125;    const arr &#x3D; this.arr.sort(this.compareFn)    return arr&#125;compareFn(a,b)&#123;    if (a - b &#x3D;&#x3D; 0) &#123;        return 0    &#125; else if (a - b &gt; 0) &#123;        return 1    &#125; else &#123;        return -1    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>但是在业务中，我们常见的都是比较数组对象中某一属性的大小，这种情况下该如何比较呢？如果是比较字符串呢？<br>在比较自定义的对象属性时，可以针对这一属性，写一个比较函数。但是原理和<code>compareFn</code>是一样的。比较字符串时，比较的是ASCII的值。</p><ol start="5"><li>搜索方法</li></ol><p><code>findIndex()</code> 和 <code>find()</code> , <code>indexOf()</code> 和 <code>includes</code> 都是搜索数组中某一值的是否存在。</p><p><strong>TypeScript中的数组</strong></p><p>如果是声明简单的数组，和 <code>const numbers : numbers[] </code> 是一样的</p><pre class="line-numbers language-none"><code class="language-none">const numbers &#x3D; [1,2,3,4,5,6]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果是声明数组对象的话，举个例子</p><pre class="line-numbers language-none"><code class="language-none">interface Person&#123;    name:String,    age:number&#125;const friends &#x3D; [    &#123;        name:&#39;Alice&#39;,        age:20    &#125;,    &#123;        name:&#39;Alice1&#39;,        age:22    &#125;]&#x2F;&#x2F; 这种情况下，我们比较friends数组中的数据年龄大小时，可以根据类型判断function compareAge(a:Person,b:Person)&#123; &#x2F;&#x2F; 这样确保我们接收的每一个值都满足了Person的类型    &#x2F;&#x2F; 函数体&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>总结</strong></p><p>在前端开发中，最常用最简单的就是数组类型数据的处理。这篇文章主要介绍了数组中常用的方法以及ES6和最新的数组的特性。接下来将会介绍栈的学习</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>什么是微前端</title>
      <link href="2021/10/30/shi-me-shi-wei-qian-duan/"/>
      <url>2021/10/30/shi-me-shi-wei-qian-duan/</url>
      
        <content type="html"><![CDATA[<h4 id="什么是微前端"><a href="#什么是微前端" class="headerlink" title="什么是微前端"></a>什么是微前端</h4><p><a href="https://micro-frontends.org/">官网</a>上是这么描述的</p><blockquote><p>Techniques, strategies and recipes for building a modern web app with multiple teams that can ship features independently.</p></blockquote><ul><li>背景</li></ul><p>从官网我们可以了解到：微前端最早是出现在2016年的ThoughtWorks Technology Radar。它将微服务的概念推广到了前端。当前的趋势是构建一个功能丰富且强大的单页面应用程序，它位于微服务架构之上。但是随着我们不断的迭代产品，前端层的业务变得繁重复杂且越来越难维护。这就是我们说的前端单体( Frontend Monolith)</p><ul><li>什么是微前端</li></ul><p>微前端背后的想法是将整个的网站或者Web应用程序看作是独立团队所拥有的功能组合，每个团队负责各自的功能模块，每个团队是跨职能的，从数据库到用户界面，端到端的开发其功能。</p><blockquote><p>通过下面这个图，我们可以更好的了解到：底部垂直排列的团队是这个架构的核心。<br>它们各自以页面或片段的形式产生特征。您可以使用 SSI 或 Web Components 之类的技术将它们集成到到达客户的组合页面中。</p></blockquote><blockquote><p><em>前端集成</em>描述了一组用于将团队的用户界面（页面和片段）组装到集成应用程序中的技术。您可以将这些技术分为三类：路由、组合和通信。根据您的架构选择，您有不同的选择来解决这些类别。</p></blockquote><p><img src="https://drek4537l1klr.cloudfront.net/geers/Figures/CH01_F01_Geers.png" alt="微前端方法大图概览"></p><p>从上述的介绍我们可以了解到微前端更像是一种概念而不是具体的技术。它是一种组织和架构的方法。</p><h4 id="微前端解决什么问题"><a href="#微前端解决什么问题" class="headerlink" title="微前端解决什么问题"></a>微前端解决什么问题</h4><ul><li>公司选择使用微前端的第一个路线是提高开发效率。在分层架构中，多个团队参与构建新的功能。减少团队之间的等待时间是微前端的主要目标<br>现在的架构都没有扩展到前端开发的概念，依然是单体、前端/后端拆分和微服务。他们都带有一个整体式的前端。<br>从这里我们可以理解微前端的优点：</li></ul><ol><li>可独立部署</li><li>将故障风险隔离到更小的区域</li><li>范围更窄，因此更容易理解</li><li>具有较小的代码库，可以在您想要重构或替换它时提供帮助；并且可以减少意外耦合的情况出现</li><li>更可预测，因为它不与其他系统共享状态</li></ol><p><strong>解决的问题：</strong></p><ol><li><p>拆分和细化<br> 当下前端领域中，单页面应用（SPA）是非常流行的前端趋势。但是随着项目的迭代，功能和代码会越来越繁杂。耦合度也会越来也高。微前端的意义之一就在于将这些繁杂的代码和功能模块进行拆分和细化</p></li><li><p>整合历史系统<br> 在不少的业务中，老系统和新系统是共存的，作为开发人员没办法浪费时间和经历将老系统进行改写。微前端可以将新旧系统进行整合。在一套系统中同时兼顾两个子系统</p></li></ol><h4 id="微前端的好处"><a href="#微前端的好处" class="headerlink" title="微前端的好处"></a>微前端的好处</h4><blockquote><p>我们不是根据特定的技术方法或实现细节来定义微前端，而是强调其出现的属性及其带来的好处</p></blockquote><ul><li>增量升级</li><li>简单、解耦的代码库</li><li>独立部署</li><li>自治团队</li></ul><h4 id="目前国内的微前端的种类"><a href="#目前国内的微前端的种类" class="headerlink" title="目前国内的微前端的种类"></a>目前国内的微前端的种类</h4><ul><li>基座模式<br>  通过搭建基座、配置中心来管理子应用。如目前大部分的单页面应用基本都会选择qiankun框架，也存在基于业务的自制方案</li><li>自组织模式<br>  通过约定进行互相调用</li><li>去中心模式<br>  脱离基座模式，，每个应用之间可以彼此分享资源。如基于<code>webpack 5 moudle Federation</code> 实现的 <strong>EMP微前端方案</strong>,可以实现多个应用彼此共享资源的分享</li></ul><h4 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h4><ol><li><a href="https://martinfowler.com/articles/microservices.html#CharacteristicsOfAMicroserviceArchitecture">微服务架构</a></li><li><a href="https://github.com/efoxTeam/emp/wiki/%E3%80%8A%E4%BB%80%E4%B9%88%E6%98%AF%E5%BE%AE%E5%89%8D%E7%AB%AF%E3%80%8B">什么是微前端</a></li><li><a href="https://martinfowler.com/articles/micro-frontends.html#IncrementalUpgrades">微前端基础</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 前端架构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
            <tag> 前端架构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue3学习二(深入理解响应性基础)</title>
      <link href="2021/10/25/vue3-xue-xi-er/"/>
      <url>2021/10/25/vue3-xue-xi-er/</url>
      
        <content type="html"><![CDATA[<p>这篇文章适合有vue基础和js基础的人学习<a href="https://v3.vuejs.org/guide/installation.html">vue3.0</a>官方关于vue3的文档是英文的，大家可以慢慢阅读。这里给大家提供一个中文版的<a href="https://www.bookstack.cn/books/vue-3.0-zh">vue3.0</a>版本的文档,建议阅读英文.也可以看视频学习，推荐一个视频<a href="https://space.bilibili.com/305684376/video">李江南vue3正式版的学习</a><br>欢迎大家访问我的博客<a href="https://github.com/dreamITGirl">dreamITGirl</a>，不要吝啬你们的小星星，点个star～ 有问题的话，你可以将问题在 <a href="https://github.com/dreamITGirl/dreamITGirl.github.io/issues">GitHub</a>问我.</p><h3 id="Vue3-x中的响应性"><a href="#Vue3-x中的响应性" class="headerlink" title="Vue3.x中的响应性"></a>Vue3.x中的响应性</h3><h4 id="Vue是如何知道哪些代码在运行的？"><a href="#Vue是如何知道哪些代码在运行的？" class="headerlink" title="Vue是如何知道哪些代码在运行的？"></a>Vue是如何知道哪些代码在运行的？</h4><blockquote><p>Vue 通过一个副作用(effect) 来跟踪当前正在运行的函数。副作用是一个函数的包裹器，在函数被调用之前就启动跟踪。Vue知道哪个副作用在何时运行，并能再次执行它</p></blockquote><pre class="line-numbers language-none"><code class="language-none">let name &#x3D; &#39;Alice&#39; , age &#x3D; 20 let mySelfInfo &#x3D; &#96;$&#123;name&#125;今年$&#123;age&#125;岁了&#96;console.log(mySelfInfo) &#x2F;&#x2F; Alice今年20岁了age &#x3D; 30 &#x2F;&#x2F; 我们预期接下来输出的是：Alice今年30岁了;console.log(mySelfInfo) &#x2F;&#x2F; Alice今年20岁了;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果我们想要让第二次输出的<code>mySelfInfo</code>中的age发生变化，就需要再次执行一下拼接的<code>mySelfInfo</code></p><pre class="line-numbers language-none"><code class="language-none">let name &#x3D; &#39;Alice&#39; , age &#x3D; 20 let mySelfInfo &#x3D; &#96;$&#123;name&#125;今年$&#123;age&#125;岁了&#96;console.log(mySelfInfo) &#x2F;&#x2F; Alice今年20岁了age &#x3D; 30mySelfInfo &#x3D; &#96;$&#123;name&#125;今年$&#123;age&#125;岁了&#96;console.log(mySelfInfo) &#x2F;&#x2F; Alice今年30岁了<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="effect"><a href="#effect" class="headerlink" title="effect"></a>effect</h5><p>在Vue2 中，通过副作用<code>effect</code>来追踪当前正常运行的函数。接下来对上述代码进行改进;<br><em>案例1</em></p><pre class="line-numbers language-none"><code class="language-none">let name &#x3D; &#39;Alice&#39; , age &#x3D; 20 let mySelfInfo &#x3D; &#39;&#39;const effectInfo &#x3D; () &#x3D;&gt; mySelfInfo &#x3D; &#96;$&#123;name&#125;今年$&#123;age&#125;岁了&#96;effectInfo()console.log(mySelfInfo) &#x2F;&#x2F; Alice今年20岁了age &#x3D; 30effectInfo()console.log(mySelfInfo) &#x2F;&#x2F; Alice今年30岁了<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>案例1的这个例子，每次更新了<code>age</code>,都要执行一下effect的方法；在Vue3中是设置了一个执行副作用的栈，然后当副作用被调用时，在调用<code>effectInfo</code>这个函数之前，会将自身推到一个数组中，这个数组可以用来检查当前正在运行的副作用</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; 维持一个执行副作用的栈const runningEffects &#x3D; []const createEffect &#x3D; fn &#x3D;&gt; &#123;  &#x2F;&#x2F; 将传来的 fn 包裹在一个副作用函数中  const effect &#x3D; () &#x3D;&gt; &#123;    runningEffects.push(effect)    effectInfo()    runningEffects.pop()  &#125;  &#x2F;&#x2F; 立即自动执行副作用  effect()&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="Vue如何追踪变化"><a href="#Vue如何追踪变化" class="headerlink" title="Vue如何追踪变化"></a>Vue如何追踪变化</h4><blockquote><p>Vue3 中使用了 Proxy，将对象包裹在一个带有<code>get</code>和<code>set</code>处理程序的 <code>Proxy</code> 中。</p></blockquote><p>Proxy是ES6的新特性，该博客也有对该API的介绍,大家可以简单看一下。<a href="https://dreamitgirl.github.io/2020/11/03/proxy/">proxy的理解</a>和<a href="https://dreamitgirl.github.io/2020/11/17/proxy-de-ying-yong-chang-jing/">proxy的应用场景</a>。</p><blockquote><p>在使用proxy的一个难点是<code>this</code>的问题。我们希望任何方法都绑定在<code>Proxy</code>，而不是目标对象。这样我们就可以拦截他们。在ES6中有一个新特性<code>Reflect</code>，它允许我们一最小的代价消除这个问题</p></blockquote><pre class="line-numbers language-none"><code class="language-none">const dinner &#x3D; &#123;  meal: &#39;apple&#39;&#125;const handler &#x3D; &#123;  get(target, property, receiver) &#123;    return Reflect.get(...arguments)  &#125;&#125;const proxy &#x3D; new Proxy(dinner, handler)console.log(proxy.meal) &#x2F;&#x2F; apple<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>使用<code>Proxy</code>实现响应性的第一步就是跟踪一个属性何时被读取，在<code>track</code>的处理器函数中执行此操作。这个函数可以传入<code>target</code> 和 <code>property</code>两个参数</p><pre class="line-numbers language-none"><code class="language-none">const dinner &#x3D; &#123;  meal: &#39;apple&#39;&#125;const handler &#x3D; &#123;  get(target, property, receiver) &#123;    track(target, property)    return Reflect.get(...arguments)  &#125;&#125;const proxy &#x3D; new Proxy(dinner, handler)console.log(proxy.meal) &#x2F;&#x2F; apple<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>track</code>将检查当前运行的是哪个副作用，并将其与 target 和 property 记录在一起。这就是Vue能知道<code>property</code>是该副作用的依赖项<br>重新修改一下<code>handle</code>函数</p><pre class="line-numbers language-none"><code class="language-none">const dinner &#x3D; &#123;  meal: &#39;apple&#39;&#125;const handler &#x3D; &#123;  get(target, property, receiver) &#123;    track(target, property)    return Reflect.get(...arguments)  &#125;,  set(target,property,value,receiver)&#123;      trigger(target,property)      return Reflect.set(...arguments)  &#125;&#125;const proxy &#x3D; new Proxy(dinner, handler)console.log(proxy.meal) &#x2F;&#x2F; apple<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>通过上述的例子，我们可以对Vue如果追踪属性的变化有了了解</p><blockquote><ol><li>当一个值被读取时进行追踪：<code>proxy</code>中的<code>get</code>处理函数中，<code>track</code>函数记录了该<code>property</code>和当前副作用</li><li>当某个值改变时进行检测: 在<code>proxy</code>上调用<code>set</code>处理函数</li><li>重新运行代码来读取原始值 <code>trigger</code>函数查找哪些副作用依赖于该<code>propery</code>并执行。</li></ol></blockquote><p>我们可以通过重写一个组件来写一个例子</p><pre class="line-numbers language-none"><code class="language-none">const vm &#x3D; createApp(&#123;    data()&#123;        return &#123;            val1:1,            val2:2        &#125;    &#125;,    computed:&#123;        sum()&#123;            return this.val1 + this.val2        &#125;    &#125;&#125;).mount(&#39;#app&#39;)console.log(vm.sum) &#x2F;&#x2F; 3vm.val1 &#x3D; 4console.log(vm.sum) &#x2F;&#x2F; 6<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于新开页面的传值问题</title>
      <link href="2021/05/20/postmessage/"/>
      <url>2021/05/20/postmessage/</url>
      
        <content type="html"><![CDATA[<p>欢迎大家访问我的博客<a href="https://github.com/dreamITGirl">dreamITGirl</a>，不要吝啬你们的小星星，点个star～ 有问题的话，你可以将问题在 <a href="https://github.com/dreamITGirl/dreamITGirl.github.io/issues">GitHub</a>问我.</p><h3 id="新开浏览器页签的传值问题"><a href="#新开浏览器页签的传值问题" class="headerlink" title="新开浏览器页签的传值问题"></a>新开浏览器页签的传值问题</h3><h4 id="1-业务背景"><a href="#1-业务背景" class="headerlink" title="1. 业务背景"></a>1. 业务背景</h4><p>在新建/修改/详情等二级或者三级新打开的页签中，需要实现传递参数的功能，并同时刷新上一级页面</p><h4 id="2-思考方式："><a href="#2-思考方式：" class="headerlink" title="2. 思考方式："></a>2. 思考方式：</h4><ol><li>使用 <code>localStorage</code> 的方式<br>这种方式的最大的弊端是当项目较大的时候存储的信息量极易超过浏览器中要求的存储空间。所以我们在第一次迭代时放弃了这种方式。</li><li>使用<code>window.postMessage</code><br>这种方式在列表页面中打开一个新建页面时是没有问题的，但是当打开多个新建页面，这个传的值就会发生问题。导致信息接收失败。在调研这个方式后也放弃了这种思路</li><li>自封装插件<br>思路：采用了JS打开页面的初始化事件，利用H5的新特性<code>history</code>来实现的。</li></ol><h4 id="3-代码解析"><a href="#3-代码解析" class="headerlink" title="3. 代码解析"></a>3. 代码解析</h4><p>主要是利用了<code>history</code>中的<code>pushState</code>和 <code>replaceState</code>这两个API，通过监听页面的渲染顺序，将函数设计成发布/订阅者模式，从而达到想要的效果</p><pre class="line-numbers language-none"><code class="language-none">function parseConfig (config) &#123; &#x2F;&#x2F; 将传递的参数String化    let str &#x3D; &#39;&#39;    for (let key in config) &#123;        if (config[key] !&#x3D;&#x3D; null) &#123;            str+&#x3D;&#96;$&#123;key&#125;&#x3D;$&#123;config[key]&#125;,&#96;        &#125;    &#125;    return str&#125;const _historyWrap &#x3D; function(type) &#123;     const orig &#x3D; history[type];    const e &#x3D; new Event(type);    return function() &#123;        const rv &#x3D; orig.apply(this, arguments);        e.arguments &#x3D; arguments;        window.dispatchEvent(e); &#x2F;&#x2F; 向一个指定的事件目标派发一个事件,  并以合适的顺序同步调用目标元素相关的事件处理函数        return rv;    &#125;&#125;;history.pushState &#x3D; _historyWrap(&#39;pushState&#39;);history.replaceState &#x3D; _historyWrap(&#39;replaceState&#39;);class Win &#123;    constructor (url, config) &#123;        config &#x3D; config || &#123;&#125;        if (!url) &#123;            throw Error(&#39;url is not defined!&#39;)        &#125;        let name &#x3D; &#39;_&#39;+Date.now() &#x2F;&#x2F; 确保name的唯一性        this.win &#x3D; window.open(url, name, parseConfig(config))        window.addEventListener(&#39;beforeunload&#39;, ()&#x3D;&gt;&#123;this.win.close()&#125;) &#x2F;&#x2F; 监听window，document 及其资源即将被载。        window.addEventListener(&#39;pushState&#39;, ()&#x3D;&gt;&#123;this.win.close()&#125;); &#x2F;&#x2F; history在会话历史堆栈顶部插入一条记录        window.addEventListener(&#39;replaceState&#39;, ()&#x3D;&gt;&#123;this.win.close()&#125;); &#x2F;&#x2F; history更新会话历史堆栈顶部记录信息        window.addEventListener(&#39;popstate&#39;, ()&#x3D;&gt;&#123;this.win.close()&#125;); &#x2F;&#x2F;history在会话历史堆栈顶部弹出一条记录        if (this.win &#x3D;&#x3D;&#x3D; null) &#123;            alert(&#39;请将“弹出式窗口和重定向”设置为允许&#39;)            throw Error(&#39;新窗口创建失败，窗口被拦截！&#39;)        &#125;        return this    &#125;    on(eventName, cb) &#123;        if (eventName &#x3D;&#x3D;&#x3D; &#39;load&#39;) &#123;            this.win.onload &#x3D; (ev) &#x3D;&gt; &#123;                cb(ev, this)            &#125;        &#125;        if (eventName &#x3D;&#x3D;&#x3D; &#39;message&#39;) &#123;            let _this &#x3D; this            function closeListener() &#123;                setTimeout(()&#x3D;&gt;&#123;                    _this.win.send &#x3D; function(message)&#123;                        cb(message)                    &#125;                    _this.win.addEventListener(&#39;unload&#39;, closeListener)                &#125;)            &#125;            this.win.addEventListener(&#39;unload&#39;, closeListener)        &#125;    &#125;    close(cb) &#123;        cb &amp;&amp; cb()        window.name &#x3D; &#39;Win_&#39;+Date.now()        this.win.open(&#39;&#39;,window.name)        window.name &#x3D; &#39;&#39;        this.win.close()    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="4-知识点链接"><a href="#4-知识点链接" class="headerlink" title="4. 知识点链接"></a>4. 知识点链接</h4><ul><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/History">history MDN文档</a></li><li><a href="https://juejin.cn/post/6844903602641862663#heading-17">history API </a></li><li><a href="https://juejin.cn/post/6844903634954633224">前端路由实现原理</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> H5 </tag>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2021.03 - 2021.04面试总结</title>
      <link href="2020/12/09/vue-gao-pin-mian-shi-ti-1/"/>
      <url>2020/12/09/vue-gao-pin-mian-shi-ti-1/</url>
      
        <content type="html"><![CDATA[<p>欢迎大家访问我的博客<a href="https://github.com/dreamITGirl">dreamITGirl</a>，不要吝啬你们的小星星，点个star～ 有问题的话，你可以将问题在 <a href="https://github.com/dreamITGirl/dreamITGirl.github.io/issues">GitHub</a>问我.</p><p>经历了一个月的准备加面试，收获也是蛮大的。今天把这一个月所经历的面试总结整理出来。这一个月面试了大厂和一些普通的公司。因为我没有react的项目以及对webpack的了解不深入，这两方面的面试题目面试官也没有深入去问。</p><h4 id="JS相关"><a href="#JS相关" class="headerlink" title="JS相关"></a>JS相关</h4><p><em>这里每个知识点单拎出来都是一个知识体系，这里总结的只是在面试中的回答方式</em></p><ol><li><p>什么是原型链？</p><ul><li>每个对象都有__proto__的属性，该属性的指向其实例对象中的原型对象的属性/方法，如果该实例对象找不到要查的属性/方法，就会向上查找该实例的原型对象的实例和方法</li><li>构造函数的prototype属性指向其原型对象</li><li>原型对象的constructor 属性指向构造函数</li></ul></li><li><p>new这个关键词</p><ul><li>创建对象，并继承该构造函数</li><li>执行该构造函数，并将this 指向新的对象实例</li><li>返回新的值</li></ul></li><li><p>JS实现new</p> <pre class="line-numbers language-none"><code class="language-none">function myNew(foo,...args)&#123;    let obj &#x3D; Object.create(foo.prototype)    let result &#x3D; foo.apply(obj,args)    return Object.prototype.toString.call(result) &#x3D;&#x3D;&#x3D; &#39;[object object]&#39; ? return : obj&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>你了解的ES5的继承</p><ul><li>原型链继承<br> <strong>原型链继承的原理</strong>：直接让子类的原型对象指向父类实例。当子类实例找不到对应的属性和方法时，就会往它的父类实例上查找，从而实现对父类的属性和方法的继承<br> <em>代码示例</em>  <pre class="line-numbers language-none"><code class="language-none">function Person()&#123;    this.name &#x3D; [&#39;Alice&#39;] &#x2F;&#x2F;如果这里只是基本类型，那么最不会出现缺点1的情况&#125;&#x2F;&#x2F; 父类原型的方法Parent.prototype.getName &#x3D; function()&#123;    return this.name&#125;&#x2F;&#x2F; 子类function Child()&#123;&#125;&#x2F;&#x2F; 让子类的原型对象指向父类实例，这样Child实例上找不到的方法和属性就会到原型对象上找Child.prototype &#x3D; new Person()Child.prototype.constructor &#x3D; Child&#x2F;&#x2F; 然后Child实例就能访问到父类及其原型上的name属性和getName()方法const c1 &#x3D; new Child()console.log(c1.name) &#x2F;&#x2F; Aliceconsole.log(c1.getName()) &#x2F;&#x2F; Alice<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre> <strong>原型链继承的缺点</strong> <ul><li>所有的Child实例原型都指向同一个Parent实例，因此对某个Child实例的父类引用类型变量修改会影响所有实例的Child实例</li><li>创建子类实例时无法向父类构造传参，没有实现<code>super()</code>的功能<pre class="line-numbers language-none"><code class="language-none">const c2 &#x3D; new Child()c1.name[0] &#x3D; &#39;foo&#39;console.log(c1.name) &#x2F;&#x2F; [&#39;foo&#39;]console.log(c2.name) &#x2F;&#x2F; [&#39;foo&#39;]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li></ul></li><li>构造函数继承<br>  构造函数的继承：是在子类的构造函数中执行父类的构造函数，并为其绑定子类的this，让父类的构造函数把成员属性和方法挂到子类的this上，这样就避免了多个实例之间共享一个原型实例，又能向父类的方法传参  <pre class="line-numbers language-none"><code class="language-none">function Parent(name) &#123;    this.name &#x3D; [name]&#125;Parent.prototype.getName &#x3D; function() &#123;    return this.name&#125;function Child() &#123;    Parent.call(this, &#39;zhangsan&#39;)   &#x2F;&#x2F; 执行父类构造方法并绑定子类的this, 使得父类中的属性能够赋到子类的this上&#125;&#x2F;&#x2F;测试const c1 &#x3D; new Child()const c2 &#x3D; new Child()c1.name[0] &#x3D; &#39;foo&#39;console.log(c1.name)          &#x2F;&#x2F; [&#39;foo&#39;]console.log(c2.name)          &#x2F;&#x2F; [&#39;zhangsan&#39;]c2.getName()  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>  <strong>构造函数继承</strong><ul><li>继承不到父类原型的属性和方法</li></ul></li><li>组合式继承<br>  原型链继承和构造函数继承组合  <pre class="line-numbers language-none"><code class="language-none">function Parent(name) &#123;    this.name &#x3D; [name]&#125;Parent.prototype.getName &#x3D; function() &#123;    return this.name&#125;function Child() &#123;    &#x2F;&#x2F; 构造函数继承    Parent.call(this, &#39;Alice&#39;) &#125;&#x2F;&#x2F;原型链继承Child.prototype &#x3D; new Parent()Child.prototype.constructor &#x3D; Child&#x2F;&#x2F;测试const c1 &#x3D; new Child()const c2 &#x3D; new Child()c1.name[0] &#x3D; &#39;foo&#39;console.log(c1.name)          &#x2F;&#x2F; [&#39;foo&#39;]console.log(c2.name)          &#x2F;&#x2F; [&#39;Alice&#39;]c2.getName() <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>  <strong>组合式继承的缺点</strong><ul><li>每次创建子类实例都执行链两次构造函数(<code>Parent.call()</code> 和 <code>new Parent()</code>),在子类创建实例时，原型中会存在两份相同的属性和方法。代码不优雅</li></ul></li><li>寄生式组合继承<br>  针对组合式继承的缺点，将指向父类实例改成指向父类的原型。这样就减少了一次构造函数的执行  <pre class="line-numbers language-none"><code class="language-none">function Parent(name) &#123;    this.name &#x3D; [name]&#125;Parent.prototype.getName &#x3D; function() &#123;    return this.name&#125;function Child() &#123;    &#x2F;&#x2F; 构造函数继承    Parent.call(this, &#39;Alice&#39;) &#125;&#x2F;&#x2F;原型链继承Child.prototype &#x3D; Object.create(Parent.prototype)  &#x2F;&#x2F;将&#96;指向父类实例&#96;改为&#96;指向父类原型&#96;Child.prototype.constructor &#x3D; Child&#x2F;&#x2F;测试const c1 &#x3D; new Child()const c2 &#x3D; new Child()c1.name[0] &#x3D; &#39;foo&#39;console.log(c1.name)          &#x2F;&#x2F; [&#39;foo&#39;]console.log(c2.name)          &#x2F;&#x2F; [&#39;Alice&#39;]c2.getName()                  &#x2F;&#x2F; [&#39;Alice&#39;]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul></li></ol><ol start="5"><li><p>this指向</p><ul><li><p>在严格模式和非严格模式中this的指向</p><p>非严格模式下，自执行函数的this指向window ；给元素的某个行为绑定一个方法，当行为触发时，执行绑定方法，此时this指向当前元素； 如果方法名前面有.，则this指向.前面的对象，如果没有，this默认指向window ； 在构造函数中，函数体中的this.xxx = xxx中的this,指的是当前类的实例 ； 使用call/apply/bind来改变this指向，传入的this是谁就指向谁</p><p>严格模式下自执行函数的this指向undefined；执行方法时，如果方法前面有.，则this指向.前面的对象，如果没有，则指向undefined</p><p>两者的区别 ： 对于JS代码中没有写执行主体的情况下，非严格模式默认时window执行的，所以this会默认执行window<br>在严格模式下，没有写执行主体，this指向undefined</p></li><li><p>普通函数、箭头函数和构造函数的this指向</p><p>普通函数由于没有对象或者实例的调用，this指向window ; 构造函数的this指向调用它的实例(在严格模式下，this为undefined)<br>箭头函数没有this，箭头函数中的this和函数或对象调用，它默认指向定义时所在上下文环境，逐级向上查找最近函数的作用域的this，箭头函数的this不会通过apply/call/bind发生改变  </p></li><li><p>node.js中的this指向</p><p>全局中的this,默认是一个空对象。在全局中的this与global对象没有任何关系，指向的是modules.exports</p><p>函数中的this，指向global对象。在函数中通过this定义的变量，都会挂载到global对象上</p><p>构造函数的this指向它的实例</p></li></ul></li></ol><ol start="6"><li><p>防抖和节流</p><ul><li><p>防抖：在时间被触发n秒后再执行回调。如果在着n秒内多次被触发，则重新计时。</p></li><li><p>使用场景： 在搜索时关键词的联想</p></li><li><p>节流 ： 高频事件触发,n秒内只执行一次，如果单位时间内多次触发，只有一次生效。节流函数稀释函数执行的频率 </p></li><li><p>使用场景： 提交表单、拖拽、缩放，防止高频触发位置变动</p></li><li><p>区别：防抖是多次触发只执行最后一次，节流是多次触发变成每隔一段时间执行一次</p></li></ul></li></ol><ol start="7"><li><p>深拷贝和浅拷贝</p><ul><li><p>深拷贝：增加了一个指针，并申请了一个新的内存，新增的这个指针指向这个新的内存</p></li><li><p>浅拷贝：只是增加了一个指针指向已存在的内存地址</p></li><li><p>区别 是否可以完全复制一个对象</p></li><li><p>代码实现</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; 不推荐function deepClone(obj)&#123;    let result &#x3D; JSON.stringify(obj)    return JSON.parse(result)&#125;function deepClone(obj)&#123;    let newObj &#x3D; obj instanceof Array ? [] :&#123;&#125;    if(typeof obj !&#x3D;&#x3D; &#39;object&#39;)&#123;&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul></li><li><p>Event Loop 事件循环机制</p><ul><li><p>JS相关知识：</p><ol><li>JS作为浏览器的脚本语言，主要是与用户交互及操作DOM。因此是单线程的，这也避免了同时操作同一个DOM的矛盾问题 </li><li>利用多核CPU的计算，H5的web worker 实现了“多线程”，实际上指的是“多子线程”，完全受控于主线程，且不允许操作DOM</li><li>JS引擎在monitoring process进程，会持续不断的进行检测主线程执行栈是否为空，一旦为空，就回去Event Queue那里检查是否有等待被调用的函数。这个过程是循环不断的，所以整个的这种运行机制又称为Event Loop（事件循环）</li><li>所有同步任务都在主线程上执行，形成一个执行栈</li><li>如果在微任务执行期间微任务的队列加入了新的微任务，会将新的微任务放在队列的尾部，之后也会被执行</li></ol></li><li><p>JS中异步操作<br>  <code>setTimeout</code> <code>setInterval</code> <code>ajax</code> <code>promise</code> <code>async await</code> <code>I/O</code></p></li><li><p>同步任务：在主线程中排队执行的任务，只有前一个任务执行完毕，才能执行后一个任务</p></li><li><p>异步任务：不进入主线程，而进入任务队列的任务，只有任务队列通知主线程，某个异步任务可以执行了，该任务才会进入主线程执行</p></li><li><p>宏任务(macro-task) : 整体代码:script,setTimeout , setInterval I/O Rendering setImediate</p></li><li><p>微任务(mincro-task) : promise.then(),process.nextTick(node) mutationObserver</p></li><li><p><a href="https://upload-images.jianshu.io/upload_images/4820992-82913323252fde95.png">事件循环机制</a>：</p><ol><li>整段script标签在开始执行的时候，会把所有的代码分为两部分：同步任务和异步任务</li><li>同步任务会直接进入到主线程中执行 </li><li>异步任务又分为微任务和宏任务</li><li>宏任务进入到Event Table 中，并在里面注册回调函数，每当指定的事件完成后，Event Table 会将这个函数移到Event Queue中</li><li>微任务也会进入到另一个Event Table中，并在里面注册回调函数，每当指定的事件完成后，Event Table 会将这个函数移到Event Queue中</li><li>当主线程内的任务执行完毕，主线程为空时，会检查微任务的Event Queue ，如果有任务，就全部执行，没有的话，就执行下一个宏任务</li><li>上述过程会不断重复，这就是Event loop事件循环</li></ol></li></ul></li><li><p>事件委托(事件代理)概念及使用场景</p><ul><li><p>什么是事件委托：<br>把元素响应事件的函数委托到其父层或者更外层元素上，当事件响应到需要绑定的元素上，利用事件冒泡的机制触发它的外层元素的事件上，然后在外层元素上执行函数</p></li><li><p>事件模型的三个阶段：捕获、目标、冒泡</p></li><li><p>事件委托的优点：减少内存的消耗 ； 动态绑定事件</p></li></ul></li></ol><ol start="10"><li><p>闭包的理解</p><ul><li><p>什么是闭包？<br>  函数A中返回了一个函数B，并且在B中使用了函数A中的变量，函数B被成为闭包</p></li><li><p>闭包的原理</p><ul><li><p>函数执行分为两个阶段：预编译阶段和执行阶段<br>在预编译阶段如果发现内部函数使用了外部函数的变量，则在内存中创建一个“闭包”对象并保存对应变量的值，如果已存在“闭包”，则只需要增加对应属性值即可；<br>执行完后，函数执行上下文会被销毁，函数对“闭包”对象的引用也会销毁，但其内部函数还持用该“闭包”的引用，所以内部函数可以继续使用外部函数的变量</p></li><li><p>利用函数作用域的特性，一个函数内部定义的函数会将包含外部函数的活动对象添加到它的作用域链中，函数执行完后，其执行作用域链仍在引用这个活动对象，所以其活动对象不会被销毁，直到内部函数被销毁后才被销毁</p></li></ul></li><li><p>闭包的特点</p><ul><li>函数嵌套函数</li><li>函数内部可以引用函数外部的参数和变量</li><li>参数和变量不会被垃圾回收机制回收 </li></ul></li><li><p>闭包的优缺点</p><ul><li><p>优点<br>  保护函数内部变量的安全，实现封装，防止变量流入其他环境发生命名冲突<br>  在内存中维持一个变量，可以作为缓存<br>  匿名自执行函数可减少内存消耗</p></li><li><p>缺点<br>  不会被垃圾回收机制回收，需要手动设置为null，否则会造成内存泄露<br>  对处理速度有负面影响，闭包的层级决定了引用的外部变量，在查找时经过的作用域链长度</p></li></ul></li><li><p>使用场景<br>  模块封装<br>  在循环中创建闭包，防止取到意外的值</p></li></ul></li><li><p>Promise的理解</p><ul><li><p>什么是Promise</p><p>  Promise 简单来说是一个容器，里面包含着某个未来才会结束的事件的结果。Promise是一个对象，从它可以获取异步操作的消息。Promise提供统一的API</p></li><li><p>Promise的特点</p><ol><li>对象不受外界的影响，有三种状态，<code>pending</code>,<code>fulfilled</code>,<code>rejected</code></li><li>一旦状态改变，就不会再变，任何时候都可以得到这个结果。从<code>pending</code>变成<code>fulfilled</code>和<code>pending</code>变成 <code>rejected</code></li></ol></li><li><p>Promise的优点</p><p>  可以将异步操作以同步操作的流程表达出来，避免了回调地狱<br>  Promise对象提供了统一的接口，使控制异步操作更加容易</p></li><li><p>Promise的缺点</p></li><li><p>Promise的常用API</p></li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> 前端面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
            <tag> 前端面试题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>XXS攻击</title>
      <link href="2020/11/25/xxs-gong-ji/"/>
      <url>2020/11/25/xxs-gong-ji/</url>
      
        <content type="html"><![CDATA[<p>欢迎大家访问我的博客<a href="https://github.com/dreamITGirl">dreamITGirl</a>，不要吝啬你们的小星星，点个star～ 有问题的话，你可以将问题在 <a href="https://github.com/dreamITGirl/dreamITGirl.github.io/issues">GitHub</a>问我.</p><h4 id="一-什么是XSS攻击"><a href="#一-什么是XSS攻击" class="headerlink" title="一. 什么是XSS攻击"></a>一. 什么是XSS攻击</h4><p>Cross-Site Scripting（跨站脚本攻击）简称 XSS，是一种代码注入攻击。攻击者通过在目标网站上注入恶意脚本，使之在用户的浏览器上运行。利用这些恶意脚本，攻击者可获取用户的敏感信息如 Cookie、SessionID 等，进而危害数据安全。</p><h4 id="二-XSS攻击的分类"><a href="#二-XSS攻击的分类" class="headerlink" title="二. XSS攻击的分类"></a>二. XSS攻击的分类</h4><p>最常见的XSS分类：反射型(非持久型)XSS、存储型(持久型)XSS、DOM型XSS、通用型XSS、突变型XSS</p><ol><li><p>反射型(非持久型)XSS<br> 反射型XSS简单的把用户输入的数据从服务器反射给用户浏览器，要利用这个漏洞，攻击者必须以某种方式诱导用户访问精心设计的URL(恶意链接)，才能实施攻击</p><p> 攻击的过程：</p><ul><li>攻击者设计出特殊的URL，其中包含恶意代码</li><li>当用户打开带有恶意代码的URL时，网站服务端将恶意代码从URL中取出，拼接在HTML中，并将内容返回给浏览器</li><li>用户浏览器接收到响应后解析执行，混在其中的恶意代码也会被执行</li><li>恶意代码会窃取用户的数据信息并发送到攻击者的网站或者冒出用户行为，调用网站的接口执行非用户本意（攻击者指定）的操作<br><img src="/2020/11/25/xxs-gong-ji/1.png" alt="反射型(非持久型)XSS攻击过程"></li></ul></li><li><p>存储型(持久型)XSS<br>存储型(持久型)XSS最常发生在由社区内容驱动的网站或Web邮件网站，不需要通过URL链接来执行。黑客仅需要提交XSS漏洞利用代码到一个网站上其他用户可能访问的地方。这些地方可能会是 <strong>评论</strong>，<strong>留言板</strong>，<strong>聊天室</strong>，<strong>HTML</strong>，<strong>电子邮件</strong>等其他许多地方，如果用户一旦感染了存储型XSS，执行就是自动的 。</p><p>攻击的过程：</p><ul><li>攻击者将恶意代码提交到目标网站的数据库中</li><li>当用户打开目标网站时，服务端将恶意代码从数据库取出，并拼接在HTML中返回给浏览器</li><li>浏览器接收到服务端响应的数据后开始解析，同时恶意代码也会被执行</li><li>恶意代码会窃取用户数据，并发送到攻击者的网站，调用目标网站执行攻击者指定的操作</li></ul><p>这种操作常见于用户保存数据的功能。<br><img src="/2020/11/25/xxs-gong-ji/2.png" alt="存储型(非持久型)XSS攻击过程"></p><p> <strong>反射型 XSS 跟存储型 XSS 的区别是：存储型 XSS 的恶意代码存在数据库里，反射型 XSS 的恶意代码存在 URL 里。</strong></p></li><li><p>DOM型XSS<br> 通过修改页面的DOM节点形成XSS攻击，不需要经过服务器的参与。属于JS自身的安全漏洞。</p><p> 攻击的过程：</p><ul><li>攻击者构造出特殊的URL，包括恶意代码</li><li>用户打开带有恶意代码的URL</li><li>浏览器收到响应后解析代码，前端JS解析代码并执行</li><li>恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。</li></ul></li></ol><h4 id="三-XSS攻击预防"><a href="#三-XSS攻击预防" class="headerlink" title="三. XSS攻击预防"></a>三. XSS攻击预防</h4><ol><li>XSS攻击的主要因素：<ul><li>攻击者提供恶意代码</li><li>浏览器解析恶意代码</li></ul></li></ol><h5 id="1-1-httponly-防止窃取cookie"><a href="#1-1-httponly-防止窃取cookie" class="headerlink" title="1.1 httponly 防止窃取cookie"></a>1.1 httponly 防止窃取cookie</h5><p>使用<code>httponly</code> 可以使浏览器禁止页面中的JS访问浏览器中的带有httponly 的 Cookie。</p><p>攻击者可以通过注入恶意脚本获取用户的 Cookie 信息。通常 Cookie 中都包含了用户的登录凭证信息，攻击者在获取到 Cookie 之后，则可以发起 Cookie 劫持攻击。所以，严格来说，HttpOnly 并非阻止 XSS 攻击，而是能阻止 XSS 攻击后的 Cookie 劫持攻击。</p><h5 id="1-2-输入检查"><a href="#1-2-输入检查" class="headerlink" title="1.2 输入检查"></a>1.2 输入检查</h5><p>前端可以将传给后台的数据中包含’&gt;’、’&lt;’等特殊字符进行转义或者过滤编码。</p><h5 id="1-3-输出检查"><a href="#1-3-输出检查" class="headerlink" title="1.3 输出检查"></a>1.3 输出检查</h5><p>除了富文本编辑器的输出外，在变量输出HTML时，可以通过<code>sanitize-html</code>对HTML进行有规则的过滤后再输出到页面</p><h5 id="1-4-输入长度的限制"><a href="#1-4-输入长度的限制" class="headerlink" title="1.4 输入长度的限制"></a>1.4 输入长度的限制</h5><p>对于不信任的输入，需要设置一个合理的长度，这样虽然无法完全防御XSS，但是可以增加XSS的攻击难度</p><h5 id="1-5-验证码"><a href="#1-5-验证码" class="headerlink" title="1.5 验证码"></a>1.5 验证码</h5><p>防止脚本冒出用户提交危险操作</p><h4 id="参考资源"><a href="#参考资源" class="headerlink" title="参考资源"></a>参考资源</h4><ol><li><a href="https://tech.meituan.com/2018/09/27/fe-security.html">美团技术团队</a></li><li><a href="https://juejin.cn/post/6844904090019840007#heading-6">前端安全系列一</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 网络安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>替换空格</title>
      <link href="2020/11/18/ti-huan-kong-ge/"/>
      <url>2020/11/18/ti-huan-kong-ge/</url>
      
        <content type="html"><![CDATA[<h3 id="替换空格"><a href="#替换空格" class="headerlink" title="替换空格"></a>替换空格</h3><p><strong>题目：</strong></p><p>请实现一个函数，把字符串 s 中的每个空格替换成”%20”。</p><p>示例：</p><blockquote><p>输入：s = “We are happy.”<br>输出：”We%20are%20happy.”</p></blockquote><p>解法一: 利用了JS中的<code>replace</code>API</p><pre class="line-numbers language-none"><code class="language-none">var replaceSpace &#x3D; function(s) &#123;    let result &#x3D; s.replace(&#x2F; &#x2F;ig,&#39;%20&#39;)    return result&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://i.loli.net/2020/11/18/2SwHLAMkQmUyuOR.png" alt="输出结果1"></p><p>解法二：将s字符串切割转换成数组，然后遍历整个数组，判断每一项中trim()方法之后的是否是true</p><pre class="line-numbers language-none"><code class="language-none">var replaceSpace &#x3D; function (s) &#123;    let m &#x3D; s.split(&#39;&#39;)    for (let i &#x3D; 0; i &lt; m.length; i++) &#123;        let item &#x3D; m[i].trim()        if (!item) &#123;            m[i] &#x3D; &#39;%20&#39;        &#125;    &#125;    m &#x3D; m.join(&#39;&#39;)    return m&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://i.loli.net/2020/11/18/eYAZOToC3cyR8ut.png" alt="输出结果2"></p><p>解法三：利用了JS中的<code>replaceAll</code>API</p><pre class="line-numbers language-none"><code class="language-none">var replaceSpace &#x3D; function (s) &#123;    let result &#x3D; s.replaceAll(&#39; &#39;,&#39;%20&#39;)    return result&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://i.loli.net/2020/11/18/NrJmIRwbzXfqgko.png" alt="输出结果3"></p><p>解法四：利用了JS中的<code>charAt</code>API</p><pre class="line-numbers language-none"><code class="language-none">var replaceSpace &#x3D; function (s) &#123;    let result &#x3D; &#39;&#39;    for (let i &#x3D; 0; i &lt; s.length; i++) &#123;        if (s.charAt(i) &#x3D;&#x3D;&#x3D; &#39; &#39;) &#123;            result +&#x3D; s[i].concat(&#39;%20&#39;).trim()        &#125; else &#123;            result +&#x3D; s[i]        &#125;    &#125;    return result&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://i.loli.net/2020/11/19/IVMrUiCW5cSXfAq.png" alt="输出结果4"></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数组中重复的数字</title>
      <link href="2020/11/18/shu-zu-zhong-chong-fu-de-shu-zi/"/>
      <url>2020/11/18/shu-zu-zhong-chong-fu-de-shu-zi/</url>
      
        <content type="html"><![CDATA[<h3 id="数组中重复的数字"><a href="#数组中重复的数字" class="headerlink" title="数组中重复的数字"></a>数组中重复的数字</h3><p><strong>题目：</strong></p><p>在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。</p><p>示例：</p><blockquote><p>输入：[2, 3, 1, 0, 2, 5, 3]，<br>输出：2 或 3</p></blockquote><p>解法一：通过中间数组，遍历原数组，如果中间数组中没有原数组中的值，则将其放到中间数组，有原数组的值，则停止循环，输出重复值</p><pre class="line-numbers language-none"><code class="language-none">var findRepeatNumber &#x3D; function(nums) &#123;    let hash &#x3D; [] , repeatItem &#x3D; undefined    for (let i &#x3D; 0; i &lt; nums.length; i++) &#123;        if (!hash.includes(nums[i])) &#123;            hash.push(nums[i])        &#125; else &#123;            repeatItem &#x3D; nums[i]            break        &#125;    &#125;    return repeatItem&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://i.loli.net/2020/11/18/dvjJrDlIWH6tVSm.png" alt="输出结果"></p><p>解法二：</p><pre class="line-numbers language-none"><code class="language-none">var findRepeatNumber &#x3D; function (nums) &#123;    const s &#x3D; new Set()    let result &#x3D; undefined    if (nums.length &gt; 0) &#123;        s.add(nums[0])    &#125;    for (let i &#x3D; 1; i &lt; nums.length; i++) &#123;        if (s.has(nums[i])) &#123;            result &#x3D; nums[i]            break        &#125; else &#123;            s.add(nums[i])        &#125;    &#125;    return result&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://i.loli.net/2020/11/18/BFDoqiJQIutKL76.png" alt="输出结果"></p><p>解法三：这种方式在数组长度较小，但是数组中的某一项值很大的时候会导致越界,但是正常情况下是性能最好的，不推荐</p><pre class="line-numbers language-none"><code class="language-none">var findRepeatNumber &#x3D; function (nums) &#123;    let temp &#x3D; undefined    for (let i &#x3D; 0; i &lt; nums.length; i++) &#123;        while (nums[i] !&#x3D; i) &#123;            if (nums[i] &#x3D;&#x3D; nums[nums[i]]) &#123;                return nums[i]            &#125;            temp &#x3D; nums[i]            nums[i] &#x3D; nums[temp]            nums[temp] &#x3D; temp        &#125;    &#125;    return -1&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://i.loli.net/2020/11/18/HDUFm4oQcxJkYId.png" alt="输出结果"></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>proxy的应用场景</title>
      <link href="2020/11/17/proxy-de-ying-yong-chang-jing/"/>
      <url>2020/11/17/proxy-de-ying-yong-chang-jing/</url>
      
        <content type="html"><![CDATA[<p>欢迎大家访问我的博客<a href="https://github.com/dreamITGirl">dreamITGirl</a>，不要吝啬你们的小星星，点个star～ 有问题的话，你可以将问题在 <a href="https://github.com/dreamITGirl/dreamITGirl.github.io/issues">GitHub</a>问我.</p><p><strong>写在前面</strong><br>随着Vue3越来越被大家学习，关于Proxy的使用也是不断收到关注。<code>Proxy</code>和<code>Object.defineProperty</code>的对比也备受关注。这篇文章适合有vue开发经验的同学阅读。</p><h4 id="回顾Object-defineProperty"><a href="#回顾Object-defineProperty" class="headerlink" title="回顾Object.defineProperty"></a>回顾<code>Object.defineProperty</code></h4><p>在vue2.x版本中，是通过<code>Object.defineProperty</code>进行双向数据绑定的，接下来看一下<code>Object.defineProperty</code>是如何进行双向绑定的。接下来简单实现一下。</p><pre class="line-numbers language-none"><code class="language-none">function observe(obj) &#123;    if (typeof obj &#x3D;&#x3D;&#x3D; &#39;object&#39; ) &#123;        for (const key in obj) &#123;            defineReactive(obj,key,obj[key])        &#125;    &#125;&#125;function defineReactive(obj,key,value) &#123;     &#x2F;&#x2F; 针对value是对象，进行递归    observe(value)    Object.defineProperty(obj,key,&#123;        get:function () &#123;            console.log(&#96;获取$&#123;key&#125;:value是$&#123;value&#125;&#96;)            return value        &#125;,        set:function (v) &#123;            observe(v)            console.log(&#96;$&#123;key&#125;数据改变了&#96;)            value &#x3D; v        &#125;    &#125;)&#125;let obj &#x3D; &#123;      name: &#39;守候&#39;,      flag: &#123;          book: &#123;              name: &#39;js&#39;,              page: 325          &#125;,          interest: [&#39;火锅&#39;, &#39;旅游&#39;],      &#125;  &#125;observe(obj)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://i.loli.net/2020/11/23/tLFbcE46hAfMIXw.png" alt="测试结果"></p><p><strong>问题一：<code>Object.defineProperty</code>无法监听增加或删除的属性</strong></p><p>我们知道<code>Object.defineProperty</code>无法监听增加或者删除的属性，<br>在我们使用vue2.x中，增加属性我们一般会通过<code>$set</code>的方法进行操作，<code>$set</code>内部也是通过使用<code>Object.defineProperty</code>实现的</p><p><img src="https://i.loli.net/2020/11/23/tVkfeP6QoA8b1C4.png" alt="测试结果1"></p><p><strong>问题二：<code>Object.defineProperty</code>无法监听到数组的变化</strong></p><p><img src="https://i.loli.net/2020/11/23/EaUgiGTpwh8H3vA.png" alt="测试结果2"></p><p>从上面的图片中我们可以看到修改数组中的值是可以的，但是不能被监听到，输出的interest数组还是改之前的数组</p><p><strong>问题三：如果对象的层级很多的情况下，不断的递归，会导致时间过长，影响性能</strong></p><h4 id="回顾Proxy"><a href="#回顾Proxy" class="headerlink" title="回顾Proxy"></a>回顾<code>Proxy</code></h4><p>vue3的版本中，采用了<code>Proxy</code>的方式。MDN 中的定义如下：</p><blockquote><p>对象用于定义基本操作的自定义行为（如属性查找、赋值、枚举、函数调用等）</p></blockquote><p>简单来说就是，对目标对象设置一层拦截，任何对这个对象的操作都会经常这层拦截。这就相当于Axios的拦截器。</p><p>接下来写个案例，理解一下Proxy</p><pre class="line-numbers language-none"><code class="language-none">function observerProxy(obj) &#123;      let handler &#x3D; &#123;          get(target, key, receiver) &#123;              console.log(&#39;获取：&#39; + key) &#x2F;&#x2F; 如果是对象，就递归添加 proxy 拦截              if (typeof target[key] &#x3D;&#x3D;&#x3D; &#39;object&#39; &amp;&amp; target[key] !&#x3D;&#x3D; null) &#123;                  return new Proxy(target[key], handler)              &#125;              return Reflect.get(target, key, receiver)          &#125;,          set(target, key, value, receiver) &#123;              console.log(key + &quot;-数据改变了&quot;)             return Reflect.set(target, key, value, receiver)          &#125;      &#125;      return new Proxy(obj, handler)  &#125;  let obj &#x3D; &#123;      name: &#39;守候&#39;,      flag: &#123;          book: &#123;              name: &#39;js&#39;,              page: 325          &#125;,          interest: [&#39;火锅&#39;, &#39;旅游&#39;],      &#125;  &#125;  let objTest &#x3D; observerProxy(obj)  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://i.loli.net/2020/11/23/TJg1GciB2FuPE9x.png" alt="Proxy输出结果"></p><p>操作数组的时候也会监听到</p><p><img src="https://i.loli.net/2020/11/23/3hUBpJHeKoX6vbl.png" alt="修改数组"></p><p>操作对象属性中是对象的时候也会监听到</p><p><img src="https://i.loli.net/2020/11/23/CqVv39JjmSt2MoE.png" alt="修改对象"></p><h4 id="比较两者的区别"><a href="#比较两者的区别" class="headerlink" title="比较两者的区别"></a>比较两者的区别</h4><p>通过上面的代码，我们不难看出来它们的区别，<code>proxy</code>还是很强大的，有11种方法。能够处理<code>Object.defineProperty</code>这个方法中无法处理的。</p><h4 id="Proxy的处理场景"><a href="#Proxy的处理场景" class="headerlink" title="Proxy的处理场景"></a>Proxy的处理场景</h4><h5 id="负索引数组"><a href="#负索引数组" class="headerlink" title="负索引数组"></a>负索引数组</h5><p>在使用<code>splice(-1)</code> 和 <code>slice(-1)</code>等API的时候，当输入的是负数时，会自动定位到数组的尾部最后一项，但是在普通的数组中，负数是不能用的。</p><pre class="line-numbers language-none"><code class="language-none">let arr &#x3D; [1,2,3]console.log(arr.splice(-1)) &#x2F;&#x2F; [3]console.log(arr[-1]) &#x2F;&#x2F; undefined<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>这种情况下我们可以通过创建一个<code>proxy</code>对象，进行控制返回值</p><pre class="line-numbers language-none"><code class="language-none">function arrProxy(params) &#123;    let handler &#x3D; &#123;        get(target,key)&#123;            if (target instanceof Array &amp;&amp; target.length &gt; 0) &#123;                if (key &gt; 0) &#123;                    return target[key]                &#125; else &#123;                    let len &#x3D; target.length                     if (key * -1 &gt; len) &#123;                        return new Error(&#39;该下标不存在&#39;)                    &#125;                    let index &#x3D; len + Number(key) &#x2F;&#x2F; key是字符串                    return target[index]                &#125;            &#125; else if (typeof target &#x3D;&#x3D;&#x3D; &#39;object&#39; &amp;&amp; target !&#x3D;&#x3D; null) &#123;                console.log(&#39;这是一个对象&#39;)                return target[key]            &#125;        &#125;    &#125;    return new Proxy(params,handler)&#125;let arr &#x3D; [1,2,3,4,5,6]let testArr &#x3D; arrProxy(arr)console.log(testArr[-1]) &#x2F;&#x2F; 6<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="表单校验"><a href="#表单校验" class="headerlink" title="表单校验"></a>表单校验</h5><p>在对于表单的验证上，当用户修改表单中的数据时，可通过<code>proxy</code>进行设置拦截。<br>举个例子：</p><pre class="line-numbers language-none"><code class="language-none">function validFrom(formObj) &#123;    let handler &#x3D; &#123;        set(target,key,value)&#123;            if (key &#x3D;&#x3D;&#x3D; &#39;age&#39;) &#123;                console.log(&#39;here&#39;,value &gt; 10 &amp;&amp; value &lt; 40,typeof value &#x3D;&#x3D; &#39;number&#39; )                if (typeof value &#x3D;&#x3D; &#39;number&#39; &amp;&amp; (value &gt; 10 &amp;&amp; value &lt; 40)) &#123;                    target[key] &#x3D; value                &#125; else &#123;                    console.log(&#39;出现错误&#39;)                    throw new Error(&#39;请输入准确的值&#39;)                &#125;            &#125;        &#125;    &#125;    return new Proxy(formObj,handler)&#125;let form &#x3D; &#123;    name:&#39;Alice&#39;,    age:20&#125;let testForm &#x3D; validFrom(form)testArr.age &#x3D; 60 &#x2F;&#x2F; &#39;请输入准确的值&#39;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="根据用户输入值，解析存储"><a href="#根据用户输入值，解析存储" class="headerlink" title="根据用户输入值，解析存储"></a>根据用户输入值，解析存储</h5><p>比如有一个需求，根据用户输入的值，将其解析分成对应属性的值。这样的话可以使用proxy。我看到网站上有其他博客写的一个案例，案例的需求是这样的，根据用户输入的身份证号码，将其所在省份、出生日期分别写在表单中的对应表格中。<br><a href="https://www.imooc.com/article/305773">文章链接</a></p><h5 id="数据格式化"><a href="#数据格式化" class="headerlink" title="数据格式化"></a>数据格式化</h5><p>数据格式化，相对来说好理解一些。当后台返回接口数据不是我们想要的格式时，我们可以通过修改设置成我们想要的格式。这里就不再举例了赘述了。</p>]]></content>
      
      
      <categories>
          
          <category> ES6系列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
            <tag> ES6 </tag>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>promise的学习</title>
      <link href="2020/11/16/promise-de-xue-xi/"/>
      <url>2020/11/16/promise-de-xue-xi/</url>
      
        <content type="html"><![CDATA[<p>欢迎大家访问我的博客<a href="https://github.com/dreamITGirl">dreamITGirl</a>，不要吝啬你们的小星星，点个star～ 有问题的话，你可以将问题在 <a href="https://github.com/dreamITGirl/dreamITGirl.github.io/issues">GitHub</a>问我.</p><p>这篇文章是阅读完<a href="https://promisesaplus.com/">promiseA+</a>规范和<a href="https://es6.ruanyifeng.com/">ES6入门教程</a>，写的总结。</p><h3 id="Promise对象"><a href="#Promise对象" class="headerlink" title="Promise对象"></a>Promise对象</h3><p>Promise 是异步编程的一种解决方案，比传统的解决方案——回调函数和事件——更合理和更强大。</p><h4 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h4><ol><li><p>promise : 是拥有then方法的对象或者函数</p></li><li><p>thenable : 定义了then方法的对象或者函数</p></li><li><p>value : 任何JS的合法值</p></li><li><p>exception : 使用throw抛出的一个值</p></li><li><p>reason : promise被拒绝的原因</p></li></ol><h4 id="Promise的状态"><a href="#Promise的状态" class="headerlink" title="Promise的状态"></a>Promise的状态</h4><ol><li><p>pending (等待) ：promise初始化状态</p></li><li><p>fulfilled (执行) : pending =&gt; resolve</p></li><li><p>rejected （拒绝）: pending =&gt; rejected</p></li></ol><h4 id="Promise方法"><a href="#Promise方法" class="headerlink" title="Promise方法"></a>Promise方法</h4><p>promise必须提供一个<code>then</code>的方法，来访问当前的最终值或者原因</p><pre class="line-numbers language-none"><code class="language-none">promise.then(onFulfilled,onRejected)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol><li><p><code>onFulfilled</code>和<code>onRejected</code>都是可选的参数，<br>如果有个不是函数的话，这个将会被忽略</p><p> 案例：</p> <pre class="line-numbers language-none"><code class="language-none">const promise &#x3D; new Promise((resolve,reject) &#x3D;&gt; &#123;    if(&#x2F;**异步执行成功**&#x2F;)&#123;        resolve(value)    &#125; else &#123;        resolve(error)    &#125;&#125;)function timeout(ms) &#123;    return new Promise((resolve, reject) &#x3D;&gt; &#123;        setTimeout(resolve, ms, &#39;done&#39;);    &#125;);&#125;timeout(100).then((value) &#x3D;&gt; &#123;    console.log(value);&#125;);&#x2F;&#x2F; 输出的结果为：&#x2F;&#x2F; Promise&#x2F;&#x2F; done<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> 上述代码中，timeout返回一个Promise实例，表示过一段时间以后才会发生的结果。<br> 过了指定的时间(ms)后，Promise的状态变为resolved,然后触发<code>.then</code>的方法绑定的回调函数</p> <pre class="line-numbers language-none"><code class="language-none">let promise &#x3D; new Promise((resolve,reject) &#x3D;&gt; &#123;    console.log(&#39;promise&#39;)    resolve()&#125;)promise.then(() &#x3D;&gt; &#123;    console.log(&#39;resolved&#39;)&#125;)console.log(&#39;Hi&#39;)&#x2F;&#x2F; 输出结果：&#x2F;&#x2F; ‘promise’&#x2F;&#x2F; ‘Hi’&#x2F;&#x2F; ‘resolved’<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> 这个例子中初始化后的Promise对象会立即执行，所以会先输出Promise，然后<code>then</code>方法制定的<br> 回调函数将在当前脚本中所有同步函数执行完后再去执行。所以，<code>resolved</code>最后输出</p> <pre class="line-numbers language-none"><code class="language-none">let promise &#x3D; new Promise(resolve &#x3D;&gt; &#123;    console.log(&#39;promise&#39;)    resolve()&#125;).then(value &#x3D;&gt; console.log(&#39;成功&#39;))console.log(&#39;here&#39;)&#x2F;&#x2F; 输出结果：&#x2F;&#x2F; &#39;promise&#39;&#x2F;&#x2F; &#39;here&#39;&#x2F;&#x2F; 成功<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> promise创建的过程是在js的同步任务中，所以会先输出promise，然后将resolve()放在微任务里。然后JS会继续执行剩下的同步任务，<br> 所以接下来会输出‘here’，最后当同步的任务执行完之后，开始执行微任务中的函数，输出‘成功’</p> <pre class="line-numbers language-none"><code class="language-none">setTimeout(()&#x3D;&gt;&#123;    console.log(&#39;setTimeout&#39;)&#125;,0)let promise &#x3D; new Promise(resolve &#x3D;&gt; &#123;    console.log(&#39;promise&#39;)    resolve()&#125;).then(value &#x3D;&gt; console.log(&#39;成功&#39;))console.log(&#39;bottom&#39;)&#x2F;&#x2F; 输出结果&#x2F;&#x2F; promise&#x2F;&#x2F; bottom&#x2F;&#x2F; 成功&#x2F;&#x2F; setTimeout<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> 代码执行中遇到setTimeout,会将setTimeout放到宏任务中，然后继续执行JS同步任务中的函数，首先是Promise的初始化，输出promise，<br> 然后遇到resolve后，会将resolve中的函数放在微任务中，继续执行同步任务中未执行的。输出bottom后，再输出成功，微任务执行完成后，会开始执行<br> 宏任务，输出setTimeout</p> <pre class="line-numbers language-none"><code class="language-none">let promise &#x3D; new Promise(resolve &#x3D;&gt; &#123;   setTimeout(() &#x3D;&gt; &#123;       console.log(&#39;setTimeout&#39;)       resolve()   &#125;,0)   console.log(&#39;promise&#39;)&#125;).then(value &#x3D;&gt; console.log(&#39;成功&#39;))console.log(&#39;bottom&#39;)&#x2F;&#x2F; 输出结果&#x2F;&#x2F; promise&#x2F;&#x2F; bottom&#x2F;&#x2F; setTimeout&#x2F;&#x2F; 成功<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> 这个例子中首先JS会定义Promise，然后开始执行，发现setTimeout会将setTimeout放在宏任务中，然后继续执行，<br> 输出promise，此时还有同步任务没有执行完，所以会继续执行console.log(‘bottom’)，输出bottom，执行完<br> 这步之后，JS同步任务已经执行完成了，接下来开始执行刚才放在宏任务中的setTimeout，先输出‘setTimeout’后，<br> 发现resolve，将其放在微任务中，如果此时setTimeout中还有其他的代码，会先执行setTimeout中的其他代码，<br> 再执行微任务中，输出‘成功’</p></li></ol><ol start="2"><li><p>Promise.prototype.then()</p><p>.then方法是定义在原型对象Promise.prototype上的。它的作用是为Promise添加回调函数。<br>第一个参数是resolve状态的回调函数，第二个参数是reject状态下的回调函数then返回一个<strong>新的</strong><code>Promise</code>实例,后面的then是对前面Promise的处理</p> <pre class="line-numbers language-none"><code class="language-none">new Promise((resolve,reject) &#x3D;&gt; &#123;    resolve(&#39;买水去了&#39;)&#125;).then(    value &#x3D;&gt; &#123;        console.log(value)    &#125;,    error &#x3D;&gt; &#123;        console.log(error)    &#125;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>Promise.prototype.catch()</p></li></ol><p>Promise.prototype.catch()的方法是.then(null,rejection) 或 .then(undefined,rejection)的别名，用于指定发生错误时的回调函数。</p><pre class="line-numbers language-none"><code class="language-none">new Promise((resolve,reject) &#x3D;&gt; &#123;    reject(new Error(&#39;出现错误&#39;))&#125;).then(value &#x3D;&gt; &#123;    console.log(value)&#125;).catch(err) &#x3D;&gt; &#123;    console.log(err) &#x2F;&#x2F; 出现错误&#125;const promise &#x3D; new Promise((resolve,reject) &#x3D;&gt; &#123;    resolve(&#39;ok&#39;)    throw new Error(&#39;test Error&#39;)&#125;)promise.then(value &#x3D;&gt; &#123;console.log(value)&#125;)    .catch(error &#x3D;&gt; &#123;console.log(error)&#125;) &#x2F;&#x2F; 输出结果&#x2F;&#x2F;ok<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果 Promise 状态已经变成resolved，再抛出错误是无效的。<br>Promise 对象的错误具有“冒泡”性质，会一直向后传递，直到被捕获为止。也就是说，错误总是会被下一个catch语句捕获。</p><ol start="4"><li>Promise.prototype.finally()</li></ol><p>finally()方法用于不管Promise对象最后的状态如何，都会执行该操作</p><pre class="line-numbers language-none"><code class="language-none">promise.then(result &#x3D;&gt; &#123;&#125;).catch(error &#x3D;&gt; &#123;&#125;).finally(() &#x3D;&gt; &#123;    &#125;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>finally方法的回调函数不接受任何参数，这就说明没办法知道前面的Promise的状态是fulfilled还是<br>rejected.这就表明，在finally中的操作不依赖Promise的执行结果</p><ol start="5"><li>Promise.all()</li></ol><p>Promise.all()方法用于多个Promise实例，包装成一个新的promise实例</p><pre class="line-numbers language-none"><code class="language-none">const p &#x3D; Promise.all([p1,p2,p3])p.then((res) &#x3D;&gt; &#123;    &#x2F;&#x2F; res是一个数组，是p1,p2,p3的返回值数组&#125;).catch((err) &#x3D;&gt; &#123;&#125;)const p1 &#x3D; new Promise((resolve, reject) &#x3D;&gt; &#123;  resolve(&#39;hello&#39;);&#125;).then(result &#x3D;&gt; result).catch(e &#x3D;&gt; e);const p2 &#x3D; new Promise((resolve, reject) &#x3D;&gt; &#123;  throw new Error(&#39;报错了&#39;);&#125;).then(result &#x3D;&gt; result).catch(e &#x3D;&gt; e);Promise.all([p1, p2]).then(result &#x3D;&gt; console.log(result)).catch(e &#x3D;&gt; console.log(e));<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://i.loli.net/2020/11/16/ZoQPcVENuqOiW4g.png" alt="输出结果"></p><p>上述代码中p1会resolved,p2首先会rejected,但是p2有自己的catch方法，该方法返回一个新的Promise<br>实例，p2的方法实际上指向这个实例。这个实例执行完catch的方法后，会变成resolveed，导致Promise<br>方法参数里的两个实例都会resolved，因此会调用then中的方法</p><p>如果p2中没有catch的方法，就会调用Promise.all()中的catch方法</p><ol start="6"><li><p>Promise.race() 和Promise.all()方法一样，这里不再赘述</p></li><li><p>Promise.allSettled() – ES2020 </p></li></ol><p>Promise.allSettled()方法接受一组 Promise 实例作为参数，包装成一个新的 Promise 实例。只有等到所有这些参数实例都返回结果，不管是fulfilled还是rejected，包装实例才会结束。该方法由 ES2020 引入。</p><pre class="line-numbers language-none"><code class="language-none">const p &#x3D; [    fetch(&#39;&#x2F;api-1),    fetch(&#39;&#x2F;api-2),    fetch(&#39;&#x2F;api-3)]await Promise.allSettled(p)removeLoadingIndicator()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面代码对服务器发出三个请求，等到三个请求都结束，不管请求成功还是失败，加载的滚动图标就会消失。</p><p>该方法返回的新的 Promise 实例，一旦结束，状态总是fulfilled，不会变成rejected。<br>状态变成fulfilled后，Promise 的监听函数接收到的参数是一个数组，<br>每个成员对应一个传入Promise.allSettled()的 Promise 实例。</p><p>当我们只关心异步操作有没有结束的时候，就可以用Promise.allSettled()的方法。Promise.all()无法确定所有请求都结束。</p><ol start="8"><li>Promise.any()<br>ES2021 引入了Promise.any()方法。该方法接受一组 Promise 实例作为参数，包装成一个新的 Promise 实例返回。<br>只要参数实例有一个变成fulfilled状态，包装实例就会变成fulfilled状态；<br>如果所有参数实例都变成rejected状态，包装实例就会变成rejected状态。</li></ol><p>Promise.any()跟Promise.race()方法很像，只有一点不同，<br>就是不会因为某个 Promise 变成rejected状态而结束</p>]]></content>
      
      
      <categories>
          
          <category> ES6系列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
            <tag> ES6 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>响应式原理的理解</title>
      <link href="2020/11/05/xiang-ying-shi-yuan-li/"/>
      <url>2020/11/05/xiang-ying-shi-yuan-li/</url>
      
        <content type="html"><![CDATA[<p>欢迎大家访问我的博客<a href="https://github.com/dreamITGirl">dreamITGirl</a>，不要吝啬你们的小星星，点个star～ 有问题的话，你可以将问题在 <a href="https://github.com/dreamITGirl/dreamITGirl.github.io/issues">GitHub</a>问我.</p><h2 id="Vue响应式原理"><a href="#Vue响应式原理" class="headerlink" title="Vue响应式原理"></a>Vue响应式原理</h2><p>在Vue的<a href="https://cn.vuejs.org/v2/guide/reactivity.html">官方文档</a>中讲到了响应式的原理。我跟着文档结合视频，把这个给整理了一下。这篇文章适合会使用Vue，具有js基础的人学习</p><ul><li>视频推荐：</li><li><a href="https://www.bilibili.com/video/BV1DT4y1L7sh">https://www.bilibili.com/video/BV1DT4y1L7sh</a></li><li><a href="https://www.bilibili.com/video/BV1c4411C7dW">https://www.bilibili.com/video/BV1c4411C7dW</a></li><li><a href="https://www.bilibili.com/video/BV1o4411k7fa">https://www.bilibili.com/video/BV1o4411k7fa</a></li></ul><h3 id="什么是响应式原理"><a href="#什么是响应式原理" class="headerlink" title="什么是响应式原理"></a>什么是响应式原理</h3><p>响应式原理是Vue的特点之一，面试vue的时候十有八九会问到，什么是数据双向绑定/什么是响应式原理。<br>响应式原理就是当修改数据模型中的某些值的时候，视图会更新</p><h3 id="响应式的理解"><a href="#响应式的理解" class="headerlink" title="响应式的理解"></a>响应式的理解</h3><ol><li><p>实现一个简单的监听属性改变的语法糖</p><pre class="line-numbers language-none"><code class="language-none">&lt;!DOCTYPE html&gt;    &lt;head&gt;        &lt;meta charset&#x3D;&quot;utf-8&quot; &#x2F;&gt;        &lt;title&gt;响应式原理的理解1&lt;&#x2F;title&gt;    &lt;&#x2F;head&gt;    &lt;body&gt;        &lt;script&gt;            &#x2F;&#x2F; 1. 实现了响应式数据的基本功能            class Vue &#123;                constructor()&#123;&#125;                set val(v)&#123;                    this.render()                &#125;                get val()&#123; &#125;                render()&#123;                  console.log(&#39;重新渲染了页面&#39;)                &#125;            &#125;             var vm &#x3D; new Vue()        &lt;&#x2F;script&gt;    &lt;&#x2F;body&gt;&lt;&#x2F;html&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们通过class类中的set，get方法，监听到vm实例上有属性改变的时候，就会触发class类的render事件<br>我们在浏览器中演示了一下，<img src="https://i.loli.net/2020/11/05/o6ERBAuMqhegWNn.gif" alt="演示结果"></p></li><li><p><code>Object.defineProperty()</code>的使用</p></li></ol><p>我们回到官方文档的介绍可以知道当我们把JS对象传给Vue中的data选项时，Vue就会遍历data中所有的属性，并通过<code>Object.defineProperty()</code>给每一个属性增加一个<code>setter/getter</code>的方法。接下来举个例子说一下<code>Object.defineProperty()</code>的用法</p><pre class="line-numbers language-none"><code class="language-none">&lt;!DOCTYPE html&gt;    &lt;head&gt;        &lt;meta charset&#x3D;&quot;utf-8&quot; &#x2F;&gt;        &lt;title&gt;响应式原理的理解2&lt;&#x2F;title&gt;    &lt;&#x2F;head&gt;    &lt;body&gt;        &lt;script&gt;            &#x2F;&#x2F; Object.defineProperty()            &#x2F;&#x2F; 这里定义一个类Vue            class Vue&#123;                constructor(opts)&#123;                    this.initData(opts.data)                &#125;                initData(data)&#123;                    for (const key in data) &#123;                        Object.defineProperty(this,key,&#123;                            set(v)&#123;                                console.log(v,&#39;v&#x3D;&#x3D;&#x3D;&#39;)                                this.render()                            &#125;,                            get()&#123;                            &#125;                        &#125;)                    &#125;                &#125;                render()&#123;                    console.log(&#39;重新渲染了DOM&#39;)                &#125;            &#125;            var vm &#x3D; new Vue(&#123;                data:&#123;                    name:&#39;Alice&#39;,                    age:20,                    dept:&#39;dept1&#39;                &#125;            &#125;)        &lt;&#x2F;script&gt;    &lt;&#x2F;body&gt;&lt;&#x2F;html&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://i.loli.net/2020/11/05/4StGJkxbeEruqlh.png" alt="演示结果"></p><p>通过结果我们可以看到，当vm实例中的name属性变化的时候，Vue类中的<code>Object.defineProperty()</code>会自动监听到值的变化，并将新的值输出给vm实例，同时触发render函数</p><p>这个案例只是讲了响应式的原理</p><h3 id="面试中该如何回答呢？"><a href="#面试中该如何回答呢？" class="headerlink" title="面试中该如何回答呢？"></a>面试中该如何回答呢？</h3><p>示例：<br> 当把一个js对象传入vue实例作为data选项，Vue会遍历此对象所有的property。并使用<code>Object.defineProperty</code>把这些property全部转化为<code>getter/setter</code>当数据中的某一属性发生变化时<code>Object.defineProperty</code>会进行数据劫持，触发setter函数，同时更新DOM，当我们获取属性的时候，<code>Object.defineProperty</code>也会进行数据劫持，返回最新的数据</p><p><code>Object.defineProperty</code>这个特性是无法使用低级浏览器中的方法来实现的，所以Vue不支持IE8以及更低版本的浏览器。<br>这些getter/setter对用户来说是不可见的，Vue是可以追踪到的，并在property被访问和修改通知变更。<br>每个组件的实例都会对应一个watcher的实例,它会在组件渲染的过程中把接触到的数据property记录为依赖，之后当依赖项的setter触发的时候，会告诉watcher，从而使它关联的组件重新渲染，这也是发布观察者订阅模式</p><p><img src="https://i.loli.net/2020/11/05/ar7SD6EhnOtzHTI.png" alt="响应式数据.png"></p>]]></content>
      
      
      <categories>
          
          <category> vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>proxy的理解</title>
      <link href="2020/11/03/proxy/"/>
      <url>2020/11/03/proxy/</url>
      
        <content type="html"><![CDATA[<p>欢迎大家访问我的博客<a href="https://github.com/dreamITGirl">dreamITGirl</a>，不要吝啬你们的小星星，点个star～ 有问题的话，你可以将问题在 <a href="https://github.com/dreamITGirl/dreamITGirl.github.io/issues">GitHub</a>问我.</p><h3 id="Proxy"><a href="#Proxy" class="headerlink" title="Proxy"></a>Proxy</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><ul><li><p>proxy用于修改某些操作的默认行为，等同于语言层面的修改，属于一种”元编程“。</p></li><li><p>proxy可以理解为，在目标对象之前设置了一层拦截，外界访问这个对象时，都要先通过这层拦截。因此提供了一种机制，可以对外界的访问进行过滤和改写。像Vue中的computed属性和双向绑定原理中都是和proxy同样的原理。</p></li><li><p>语法</p><pre class="line-numbers language-none"><code class="language-none">const p &#x3D; new Proxy(target,handler)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>target：要使用proxy包装的目标对象（可以是任何类型的对象，包括原生数组、函数，甚至另一个代理）</p></li><li><p>handler:一个通常以函数作为属性的对象，各属性的函数分别定义了在执行各种操作时代理p的行为</p></li><li><p>举个例子</p><pre class="line-numbers language-none"><code class="language-none">var handler &#x3D; &#123;    get:function(target,name)&#123;        console.log(target,name)        return 66    &#125;&#125;var proxy &#x3D; new Proxy(&#123;&#125;,handler)console.log(proxy.name)console.log(proxy.time)console.log(proxy.title)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://i.loli.net/2020/11/17/4Rxs8CnJUaPfBzH.png" alt="输出结果"></p></li></ul><pre class="line-numbers language-none"><code class="language-none">var handler &#x3D; &#123;    get:function(target,name)&#123;        console.log(&#39;get方法&#39;)        return 77    &#125;,    set:function(target,name,value)&#123;        console.log(&#39;set方法&#39;)        target[name] &#x3D; value    &#125;&#125;var proxy &#x3D; new Proxy(&#123;&#125;,handler)console.log(proxy.name)console.log(proxy.time)proxy.title &#x3D; &#39;测试代码&#39;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://i.loli.net/2020/11/17/7ihaTAEXMDQ43zg.png" alt="输出结果"></p><ul><li><p>一个技巧是将 Proxy 对象，设置到object.proxy属性，从而可以在object对象上调用；Proxy 实例也可以作为其他对象的原型对象；<br>同一个拦截函数可以设置多个拦截操作</p></li><li><p>再举个例子</p><pre class="line-numbers language-none"><code class="language-none">var handler &#x3D; &#123;    get:function(target,name)&#123;        if(name &#x3D;&#x3D; &#39;prototype&#39;)&#123;            return Object.prototype        &#125;        return &#39;Hello&#39; + name    &#125;,    apply:function(target,thisBinding,args)&#123;        console.log(thisBinding) &#x2F;&#x2F; 被调用时的上下文对象。        return args[0]    &#125;,    construct:function(target,args)&#123;        return &#123;value:args[1]&#125;    &#125;&#125;var fproxy &#x3D; new Proxy(function(x,y) &#123;    return x+y&#125;,handler)fproxy(1, 2) &#x2F;&#x2F; 1new fproxy(1, 2) &#x2F;&#x2F; &#123;value:2&#125;fproxy.prototype &#x3D;&#x3D;&#x3D; Object.prototype &#x2F;&#x2F; truefproxy.foo &#x3D;&#x3D;&#x3D; &quot;Hello, foo&quot; &#x2F;&#x2F; true<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>Proxy支持的拦截操作：</p><ul><li><p>get(target,property,receiver) : 拦截对象属性的读取</p></li><li><p>set(target,property,value,receiver):拦截对象属性的设置，返回一个布尔值</p></li><li><p>has(target,property): 拦截<code>property in proxy</code>的操作，返回一个布尔值</p></li><li><p>ownKeys(target):拦截<code>Object.getOwnPropertyNames(proxy)、Object.getOwnPropertySymbols(proxy)、Object.keys(proxy)、for...in</code>循环，返回一个数组。该方法返回目标对象所有自身的属性的属性名，而Object.keys()的返回结果仅包括目标对象自身的可遍历属性。</p></li><li><p>getOwnPropertyDescriptor(target, propKey)：拦截<code>Object.getOwnPropertyDescriptor(proxy, propKey)</code>，返回属性的描述对象。</p></li><li><p>defineProperty(target, propKey, propDesc)：拦截<code>Object.defineProperty(proxy, propKey, propDesc）、Object.defineProperties(proxy, propDescs)</code>，返回一个布尔值。</p></li><li><p>preventExtensions(target)：拦截<code>Object.preventExtensions(proxy)</code>，返回一个布尔值。</p></li><li><p>getPrototypeOf(target)：拦截<code>Object.getPrototypeOf(proxy)</code>，返回一个对象</p></li><li><p>isExtensible(target)：拦截<code>Object.isExtensible(proxy)</code>，返回一个布尔值</p></li><li><p>setPrototypeOf(target, proto)：拦截<code>Object.setPrototypeOf(proxy, proto)</code>，返回一个布尔值。如果目标对象是函数，那么还有两种额外操作可以拦截</p></li><li><p>apply(target, object, args)：拦截 Proxy 实例作为函数调用的操作，比如<code>proxy(...args)、proxy.call(object, ...args)、proxy.apply(...)</code>。</p></li><li><p>construct(target, args)：拦截 Proxy 实例作为构造函数调用的操作，比如new <code>proxy(...args)</code>。</p></li></ul></li></ul><h4 id="实例方法"><a href="#实例方法" class="headerlink" title="实例方法"></a>实例方法</h4><ol><li><p><strong><code>get()</code></strong><br> 该方法会拦截目标对象的以下操作</p><ul><li><p>访问属性：<code>proxy[foo]和proxy.bar</code></p></li><li><p>访问原型链上的属性：<code>Object.create(proxy)[foo]</code></p></li><li><p><code>reflect.get()</code></p><p>以下情况，proxy会抛出<code>TypeError</code></p></li><li><p>如果访问的目标属性是不可写以及不可配置的，则返回的值必须与该目标属性的值相同</p></li><li><p>如果要访问的目标属性没有配置访问的方法，即get方法是undefined，则返回值必须是undefined</p></li></ul><p><em>举个例子</em></p><pre class="line-numbers language-none"><code class="language-none">var person &#x3D; &#123;    name:&#39;Alice&#39;&#125;,handler &#x3D; &#123;    get:function(target,propkey)&#123;        if(propkey in target)&#123;            return target[propkey]        &#125; else &#123;            throw new ReferenceError(&#96;prop name $&#123;propkey&#125; does not exist.&#96;)        &#125;    &#125;&#125;var proxy &#x3D; new Proxy(person,handler)console.log(proxy.name) &#x2F;&#x2F; Aliceconsole.log(proxy.age) &#x2F;&#x2F; ReferenceError<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> <strong>get方法可以继承</strong></p> <pre class="line-numbers language-none"><code class="language-none"> let proto &#x3D; new Proxy(&#123;&#125;,&#123;    get:function(target,name,receiver)&#123;        console.log(&#39;get&#39;+name)        return target[name]    &#125; &#125;)let obj &#x3D; Object.create(proto)console.log(obj.foo) &#x2F;&#x2F; getfoo<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><strong><code>set()</code></strong><br>该方法会拦截目标对象的以下操作</p><ul><li>指定属性值 <code>proxy[foo] = bar</code> 和 <code>proxy.foo = bar</code>  </li><li>指定继承者的属性值：<code>Object.create(proxy)[foo] = bar </code></li><li>reflect.set()</li></ul><p>以下的情况，proxy 会抛出一个 TypeError 异常：</p><ul><li>若目标属性是一个不可写及不可配置的数据属性，则不能改变它的值。</li><li>如果目标属性没有配置存储方法，即 [[Set]] 属性的是 undefined，则不能设置它的值。</li><li>在严格模式下，如果 set() 方法返回 false，那么也会抛出一个 TypeError 异常</li></ul><p> <em>举个例子</em></p> <pre class="line-numbers language-none"><code class="language-none">let p &#x3D; new Proxy(&#123;&#125;,&#123;    set:function(target,prop,value,receiver)&#123;        target[prop] &#x3D; value        console.log(&#96;property set $&#123;prop&#125; &#x3D; $&#123;value&#125;&#96;)        return true    &#125;&#125;)console.log(&#39;name&#39; in p)  &#x2F;&#x2F; falsep.name &#x3D; 10console.log(&#39;name&#39; in p) &#x2F;&#x2F; trueconsole.log(p.name) &#x2F;&#x2F; 10<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> <img src="https://i.loli.net/2020/11/17/sIZLMRkuTlVY4Eg.png" alt="输出结果"></p> <pre class="line-numbers language-none"><code class="language-none">const handler &#x3D; &#123;    set:function(target,prop,value,receiver)&#123;        target[prop] &#x3D; receiver    &#125;&#125;const proxy &#x3D; new Proxy(&#123;&#125;,handler)proxy.foo &#x3D; &#39;bar&#39;proxy,foo &#x3D;&#x3D;&#x3D; proxy<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> <img src="https://i.loli.net/2020/11/17/SUxViMyCZwPoDbz.png" alt="输出结果"></p> <pre class="line-numbers language-set```方法的第四个参数```receiver```，一般情况下```proxy```实例本身" data-language="set```方法的第四个参数```receiver```，一般情况下```proxy```实例本身"><code class="language-set```方法的第四个参数```receiver```，一般情况下```proxy```实例本身">&#96;&#96;&#96;const handler &#x3D; &#123;    set: function(obj, prop, value, receiver) &#123;        obj[prop] &#x3D; receiver;    &#125;&#125;;const proxy &#x3D; new Proxy(&#123;&#125;, handler);const myObj &#x3D; &#123;&#125;;Object.setPrototypeOf(myObj, proxy);myObj.foo &#x3D; &#39;bar&#39;;myObj.foo &#x3D;&#x3D;&#x3D; myObj<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><strong><code>apply()</code></strong><br> 该方法会拦截目标对象的以下操作：</p><ul><li><p>proxy(…args)</p></li><li><p><code>Function.prototype.apply()</code> 和 <code>Function.prototype.call()</code></p></li><li><p><code>Reflect.apply()</code></p><p>以下情况，代理将抛出一个TypeError：</p></li><li><p>target必须是可被调用的。也就是说，它必须是一个函数对象。</p></li></ul><p> <em>举个例子</em></p> <pre class="line-numbers language-none"><code class="language-none">var p &#x3D; new Proxy(function() &#123;&#125;, &#123;            apply: function(target, thisArg, argumentsList) &#123;                console.log(&#39;called: &#39; + argumentsList.join(&#39;, &#39;));                return argumentsList[0] + argumentsList[1] + argumentsList[2];            &#125;        &#125;);console.log(p(1,2,3))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><strong><code>construct()</code></strong><br> 该方法用于拦截new操作符，为了使<code>new</code>操作符在生成的proxy对象上生效，用于初始化代理的目标对象自身必须具有[[<code>Construct</code>]]内部方法(也就是说<code>new target</code> 必须是有效的)</p><p> <em>举个例子</em></p> <pre class="line-numbers language-none"><code class="language-none">var p &#x3D; new Proxy(function()&#123;&#125;,&#123;    construct:function(target,args,newTarget)&#123;        console.log(&#96;called $&#123;args.join(&#39;,&#39;)&#125;&#96;)        return &#123;value:args[0] * 10&#125;    &#125;&#125;)console.log(new p(1).value)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> <img src="https://i.loli.net/2020/11/17/jBsqTwRSZ7LJxkh.png" alt="输出结果"></p></li></ol><h4 id="this问题"><a href="#this问题" class="headerlink" title="this问题"></a>this问题</h4><blockquote><p>虽然 Proxy 可以代理针对目标对象的访问，但它不是目标对象的透明代理，即不做任何拦截的情况下，也无法保证与目标对象的行为一致。主要原因就是在 Proxy 代理的情况下，目标对象内部的this关键字会指向 Proxy 代理。</p></blockquote><pre class="line-numbers language-none"><code class="language-none">const target &#x3D; &#123;  m: function () &#123;    console.log(this &#x3D;&#x3D;&#x3D; proxy);  &#125;&#125;;const handler &#x3D; &#123;&#125;;const proxy &#x3D; new Proxy(target, handler);target.m() &#x2F;&#x2F; falseproxy.m()  &#x2F;&#x2F; true<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面的代码中，一旦proxy代理了target,targot内部的this的指向就会指向proxy,</p>]]></content>
      
      
      <categories>
          
          <category> ES6系列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
            <tag> ES6 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue3的学习一</title>
      <link href="2020/11/02/vue3/"/>
      <url>2020/11/02/vue3/</url>
      
        <content type="html"><![CDATA[<p>欢迎大家访问我的博客<a href="https://github.com/dreamITGirl">dreamITGirl</a>，不要吝啬你们的小星星，点个star～ 有问题的话，你可以将问题在 <a href="https://github.com/dreamITGirl/dreamITGirl.github.io/issues">GitHub</a>问我.<br>这篇文章适合有vue基础和js基础的人学习<a href="https://v3.vuejs.org/guide/installation.html">vue3.0</a>官方关于vue3的文档是英文的，大家可以慢慢阅读。这里给大家提供一个中文版的<a href="https://www.bookstack.cn/books/vue-3.0-zh">vue3.0</a>版本的文档,建议阅读英文.也可以看视频学习，推荐一个视频<a href="https://space.bilibili.com/305684376/video">李江南vue3正式版的学习</a></p><h2 id="vue3的亮点"><a href="#vue3的亮点" class="headerlink" title="vue3的亮点"></a>vue3的亮点</h2><ol><li> Performance 性能比vue 2.x快1.2～2倍</li><li> Tree shanking support 按需编译，体积比vue2.x更小</li><li> Composition API（组合API）</li><li> Better TypeScript support 更好的TS支持</li><li> Cunstom Render API : 暴露了自定义渲染的API</li><li> Fragment,Teleport(Protal),Suspense: 更先进的组件</li></ol><h2 id="vue3-是如何变快的？"><a href="#vue3-是如何变快的？" class="headerlink" title="vue3 是如何变快的？"></a>vue3 是如何变快的？</h2><h3 id="diff算法优化"><a href="#diff算法优化" class="headerlink" title="diff算法优化"></a>diff算法优化</h3><p>在vue2中的虚拟dom是进行全量对比的，也就是说，更新一处，所有的dom节点都会重新对比一遍。<br>在vue3中增加了静态标记，只需要进行比较flag的节点，并且可以通过flag的标志符判断更新的具体内容</p><pre class="line-numbers language-none"><code class="language-none">&lt;div&gt;    &lt;p&gt;测试&lt;&#x2F;p&gt;    &lt;p&gt;&#123;&#123;msg&#125;&#125;&lt;&#x2F;p&gt;&lt;&#x2F;div&gt;&#x2F;&#x2F; vue2x中：编译后的js代码function anonymous() &#123;  with(this) &#123;    return _c(&#39;div&#39;, [_ssrNode(&quot;&lt;p&gt;测试&lt;&#x2F;p&gt; &lt;p&gt;&quot; + _ssrEscape(_s(msg)) + &quot;&lt;&#x2F;p&gt;&quot;)])  &#125;&#125;&#x2F;&#x2F; vue3x中：编译后的代码import &#123; createVNode as _createVNode, toDisplayString as _toDisplayString, openBlock as _openBlock, createBlock as _createBlock &#125; from &quot;vue&quot;export function render(_ctx, _cache, $props, $setup, $data, $options) &#123;  return (_openBlock(), _createBlock(&quot;div&quot;, null, [    _createVNode(&quot;p&quot;, null, &quot;测试&quot;),    _createVNode(&quot;p&quot;, null, _toDisplayString(_ctx.msg), 1 &#x2F;* TEXT *&#x2F;)  ]))&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们可以看到在vue3中在渲染虚拟dom的时候就标记了一个flag用于后面更新比较</p><h3 id="静态提升"><a href="#静态提升" class="headerlink" title="静态提升"></a>静态提升</h3><p>vue2 中，无论创建的元素是否参与更新，每次都会被重新创建，然后再渲染<br>vue3 中，对于不参与更新的元素，会做静态提升，只会被创建一次，在渲染的时候直接复用</p><pre class="line-numbers language-none"><code class="language-none">&lt;div&gt;  &lt;p&gt;测试&lt;&#x2F;p&gt;  &lt;p&gt;测试&lt;&#x2F;p&gt;  &lt;p&gt;测试&lt;&#x2F;p&gt;  &lt;p&gt;&#123;&#123;msg&#125;&#125;&lt;&#x2F;p&gt;&lt;&#x2F;div&gt;&#x2F;&#x2F;静态提升之前：export function render(_ctx, _cache, $props, $setup, $data, $options) &#123;  return (_openBlock(), _createBlock(&quot;div&quot;, null, [    _createVNode(&quot;p&quot;, null, &quot;测试&quot;),    _createVNode(&quot;p&quot;, null, &quot;测试&quot;),    _createVNode(&quot;p&quot;, null, &quot;测试&quot;),    _createVNode(&quot;p&quot;, null, _toDisplayString(_ctx.msg), 1 &#x2F;* TEXT *&#x2F;)  ]))&#125;&#x2F;&#x2F;静态提升之后const _hoisted_1 &#x3D; &#x2F;*#__PURE__*&#x2F;_createVNode(&quot;p&quot;, null, &quot;测试&quot;, -1 &#x2F;* HOISTED *&#x2F;)const _hoisted_2 &#x3D; &#x2F;*#__PURE__*&#x2F;_createVNode(&quot;p&quot;, null, &quot;测试&quot;, -1 &#x2F;* HOISTED *&#x2F;)const _hoisted_3 &#x3D; &#x2F;*#__PURE__*&#x2F;_createVNode(&quot;p&quot;, null, &quot;测试&quot;, -1 &#x2F;* HOISTED *&#x2F;)export function render(_ctx, _cache, $props, $setup, $data, $options) &#123;  return (_openBlock(), _createBlock(&quot;div&quot;, null, [    _hoisted_1,    _hoisted_2,    _hoisted_3,    _createVNode(&quot;p&quot;, null, _toDisplayString(_ctx.msg), 1 &#x2F;* TEXT *&#x2F;)  ]))&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="cancleHandlers-事件侦听器缓存"><a href="#cancleHandlers-事件侦听器缓存" class="headerlink" title="cancleHandlers 事件侦听器缓存"></a>cancleHandlers 事件侦听器缓存</h3><p>默认情况下，onClick会被认定为动态绑定，每次都会追踪它的变化<br>但是因为是同一个函数，在没有追踪到变化时，直接缓存起来复用即可</p><pre class="line-numbers language-none"><code class="language-none">&lt;div&gt;  &lt;button @click&#x3D;&quot;clickFunc&quot;&gt;点击&lt;&#x2F;button&gt;&lt;&#x2F;div&gt;&#x2F;&#x2F; 开启事件侦听器缓存之前：export function render(_ctx, _cache, $props, $setup, $data, $options) &#123;  return (_openBlock(), _createBlock(&quot;div&quot;, null, [    _createVNode(&quot;button&quot;, &#123; onclick: _ctx.clickFunc &#125;, &quot;点击&quot;, 32 &#x2F;* PROPS, HYDRATE_EVENTS *&#x2F;, [&quot;onOnclick&quot;])  ]))&#125;&#x2F;&#x2F; 开启事件侦听器缓存之后：export function render(_ctx, _cache, $props, $setup, $data, $options) &#123;  return (_openBlock(), _createBlock(&quot;div&quot;, null, [    _createVNode(&quot;button&quot;, &#123;      onOnclick: _cache[1] || (_cache[1] &#x3D; (...args) &#x3D;&gt; (_ctx.clickFunc(...args)))    &#125;, &quot;点击&quot;, 32 &#x2F;* HYDRATE_EVENTS *&#x2F;)  ]))&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>⚠️:在vue的diff算法中，只有静态标记的才会进行比较，才会进行追踪</strong></p><h2 id="vue3项目的创建"><a href="#vue3项目的创建" class="headerlink" title="vue3项目的创建"></a>vue3项目的创建</h2><p>创建vue3的项目可以和vue2的方式一样，这里说的是vue3中新推出的vite的方式</p><h3 id="什么是Vite"><a href="#什么是Vite" class="headerlink" title="什么是Vite"></a>什么是Vite</h3><p>Vite 是一个由原生 ESM 驱动的 Web 开发构建工具。在开发环境下基于浏览器原生 ES imports 开发，在生产环境下基于 Rollup 打包。<br>它主要具有以下特点：</p><ol><li>快速的冷启动</li><li>即时的模块热更新</li><li>真正的按需编译<h3 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h3><pre class="line-numbers language-none"><code class="language-none">npm install -g create-vite-app &#x2F;&#x2F; 全局安装vitecreate-vite-app vue3Project &#x2F;&#x2F; 创建项目名为vue3Project的项目cd vue3Projectnpm inpm run dev &#x2F;&#x2F; 测试环境启动项目 <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>这里就不再仔细讲构建的项目中的目录结构了</li></ol><h2 id="组合API"><a href="#组合API" class="headerlink" title="组合API"></a>组合API</h2><h3 id="v-for-Array-Refs"><a href="#v-for-Array-Refs" class="headerlink" title="v-for Array Refs"></a>v-for Array Refs</h3><blockquote><p>In Vue 2, using the ref attribute inside v-for will populate the corresponding $refs property with an array of refs. This behavior becomes ambiguous and inefficient when there are nested v-fors present.<br>在vue2中，在v-for中使用的ref属性，会用ref数组填充相应的$refs的属性。如果遇到嵌套的v-for的时候，行动就会不明确且效率就会变得很低</p></blockquote><blockquote><p>In Vue 3, such usage will no longer automatically create an array in $refs. To retrieve multiple refs from a single binding, bind ref to a function which provides more flexibility (this is a new feature):<br>在vue3中，这样使用不会在$refs中自动创建数组。要从单个绑定绑定获取多个ref时，需要将ref绑定到一个更灵活的函数上</p></blockquote><p><strong>案例一</strong></p><pre class="line-numbers language-none"><code class="language-none">&lt;template&gt;  &lt;div&gt;    &lt;p&gt;count:&#123;&#123; count &#125;&#125;&lt;&#x2F;p&gt;    &lt;button @click&#x3D;&quot;testFn&quot;&gt;按钮&lt;&#x2F;button&gt;  &lt;&#x2F;div&gt;&lt;&#x2F;template&gt;&lt;script&gt;&#x2F;&#x2F; ref函数注意点：&#x2F;&#x2F; ref 只能监听简单类型的数据变化，不能监听复杂类型的数据变化(对象&#x2F;数组)import &#123;ref&#125; from &#39;vue&#39;export default &#123;  name: &#39;App&#39;,  &#x2F;&#x2F; setup函数是组合API的入口函数  setup()&#123;    let count &#x3D; ref(0) &#x2F;&#x2F;是一个对象    &#x2F;&#x2F; 在组合API中想定义方法，不用写在methods中，直接定义抛出就可以了    function testFn() &#123;        count.value +&#x3D; 1    &#125;    &#x2F;&#x2F; 注意点：    &#x2F;&#x2F; 在组合API中定义的变量&#x2F;方法，要想在外界使用，需要通过return&#123;xxx,xxx&#125;暴露出去    return &#123;count,testFn&#125;  &#125;&#125;&lt;&#x2F;script&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>案例二</strong></p><pre class="line-numbers language-none"><code class="language-none">&lt;template&gt;    &lt;div&gt;        &lt;form&gt;            &lt;label&gt;                id: &lt;input type&#x3D;&quot;text&quot; v-model&#x3D;&quot;stuForm.stu.id&quot;&gt;            &lt;&#x2F;label&gt;            &lt;label&gt;                name: &lt;input type&#x3D;&quot;text&quot; v-model&#x3D;&quot;stuForm.stu.name&quot;&gt;            &lt;&#x2F;label&gt;            &lt;label&gt;                age: &lt;input type&#x3D;&quot;text&quot; v-model&#x3D;&quot;stuForm.stu.age&quot;&gt;            &lt;&#x2F;label&gt;            &lt;button type&#x3D;&quot;button&quot; @click.stop.prevent&#x3D;&quot;addStu&quot;&gt; 添加&lt;&#x2F;button&gt;        &lt;&#x2F;form&gt;        &lt;h5&gt;列表展示&lt;&#x2F;h5&gt;        &lt;p v-for&#x3D;&quot;(item,index) in state.stus&quot; :key&#x3D;&quot;item.id&quot; @click&#x3D;&quot;removeStu(index)&quot;&gt;            &#123;&#123;item.name&#125;&#125; - &#123;&#123;item.age&#125;&#125;        &lt;&#x2F;p&gt;            &lt;&#x2F;div&gt;&lt;&#x2F;template&gt;&lt;script&gt;import &#123;reactive&#125; from &#39;vue&#39;export default &#123;    name: &#39;App&#39;,    setup()&#123;        &#x2F;**          * let state &#x3D; reactive(&#123;            stus:[                &#123;id:1,name:&#39;lucy&#39;,age:10&#125;,                &#123;id:2,name:&#39;john&#39;,age:12&#125;,                &#123;id:3,name:&#39;lucy&#39;,age:15&#125;,                &#123;id:4,name:&#39;alice&#39;,age:14&#125;            ]        &#125;)        console.log(&#39;state&#39;,state)        function removeStu(index) &#123;            state.stus &#x3D; state.stus.filter((stu,ind) &#x3D;&gt; ind !&#x3D;&#x3D; index)        &#125;        return &#123;state,removeStu&#125;         **&#x2F;        let &#123;state,removeStu&#125; &#x3D; stuFunc()        let stuForm &#x3D; reactive(&#123;            stu:&#123;                id:&#39;&#39;,                name:&#39;&#39;,                age:&#39;&#39;            &#125;        &#125;)        function addStu() &#123;             let stuObj &#x3D; Object.assign(&#123;&#125;,stuForm.stu)             state.stus.push(stuObj)             stuForm.stu.id &#x3D; &#39;&#39;            stuForm.stu.name &#x3D; &#39;&#39;            stuForm.stu.age &#x3D; &#39;&#39;        &#125;        return &#123;state,removeStu,stuForm,addStu&#125;    &#125;&#125;function stuFunc() &#123;    let state &#x3D; reactive(&#123;        stus:[            &#123;id:1,name:&#39;lucy&#39;,age:10&#125;,            &#123;id:2,name:&#39;john&#39;,age:12&#125;,            &#123;id:3,name:&#39;lucy&#39;,age:15&#125;,            &#123;id:4,name:&#39;alice&#39;,age:14&#125;        ]    &#125;)    function removeStu(index) &#123;        state.stus &#x3D; state.stus.filter((stu,ind) &#x3D;&gt; ind !&#x3D;&#x3D; index)    &#125;    return &#123;state,removeStu&#125;&#125;&lt;&#x2F;script&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这两个案例，讲了如何使用组合API，以及我们可以将我们的函数封装成一个js文件，通过export的方式引入；这样在开发中，使得我们的代码更简洁，更便于维护</p><p><strong>Composition API(组合API/注入API)的本质</strong><br>将setup中定义的函数或变量，注入到Option API 中的methods或者data属性中</p><p><strong>setup函数</strong></p><ul><li>执行时机：<br> 在beforeCreate 和 Created 生命周期之间执行 </li><li>注意点<ul><li>由于在执行setup函数时，组件中的data和methods还没有被创建好，所以无法使用data/mehtods中的属性的</li><li>setup函数中的this被修改为了undefined</li><li>setup函数只能是同步的不能是异步的</li></ul></li></ul><h2 id="Reactivity-API"><a href="#Reactivity-API" class="headerlink" title="Reactivity API"></a>Reactivity API</h2><p>The Reactivity API contains the following sections:</p><ol><li>Basic Reactivity APIs</li><li>Refs</li><li>Computed and watch</li></ol><h3 id="reactive的理解"><a href="#reactive的理解" class="headerlink" title="reactive的理解"></a>reactive的理解</h3><blockquote><p>Returns a reactive copy of the object.<br>    The reactive conversion is “deep”—it affects all nested properties. In the ES2015 Proxy based implementation, the returned proxy is not equal to the original object. It is recommended to work exclusively with the reactive proxy and avoid relying on the original object.</p></blockquote><ul><li><p>reactive 是vue3中提供的实现响应式数据的方法</p><ul><li>在vue2中，通过defineProperty的属性来监听数据的变化</li><li>vue3中的响应式数据通过ES6的<a href="https://dreamitgirl.github.io/2020/11/03/proxy/">proxy的学习</a> 来实现的.</li></ul></li><li><p>reactive的注意点</p><ul><li>reactive的参数必须是Object(json/Array) </li><li>如果给reactive传了其他的对象，默认情况下，不会更新视图界面。如果想要更新，需要重新赋值</li></ul><p><strong>案例</strong></p><pre class="line-numbers language-none"><code class="language-none">&lt;template&gt;    &lt;div&gt;        &lt;p&gt;&#123;&#123;state&#125;&#125;&lt;&#x2F;p&gt;         &lt;p&gt;&#123;&#123;state.time&#125;&#125;&lt;&#x2F;p&gt;        &lt;button @click&#x3D;&quot;changeVal&quot;&gt;按钮&lt;&#x2F;button&gt;    &lt;&#x2F;div&gt;&lt;&#x2F;template&gt;&lt;script&gt;import &#123; reactive &#125; from &#39;vue&#39;export default &#123;    name:&#39;App&#39;,    setup()&#123;      &#x2F;&#x2F; 当给reactive传的参数是其他类型的时候，页面上是可以正常显示的。但是控制台会有一句警告      &#x2F;&#x2F; vue.js:948 value cannot be made reactive: 2       let state &#x3D; reactive(2)      function changeVal() &#123;          state &#x3D; 34          &#x2F;&#x2F; 输出的state的值改变了，但是视图并未更新，说明当传递给reactive的参数不是对象的时候，vue无法监听到数据的变化          console.log(state) &#x2F;&#x2F; 34      &#125;      return &#123;state,changeVal&#125;      &#x2F;&#x2F; 当传给reactive的参数是一个数组的时候，修改数据的值，视图中的数据是可以变化的        let state &#x3D; reactive([1,2,3])        function changeVal() &#123;            state[2] &#x3D; 666        &#125;        return &#123;state,changeVal&#125;     &#x2F;&#x2F; 当传递的参数是不是一个对象时    let state &#x3D; reactive(&#123;        time:new Date()    &#125;)    function changeVal() &#123;        &#x2F;&#x2F; 直接修改的话，视图没有发生改变 , 可以通过重新赋值的方式         &#x2F;&#x2F; state.time.setDate(state.time.getDate() + 1)        &#x2F;&#x2F; 将新值重新赋值给state.time,视图会跟着变化        const time2 &#x3D; new Date(state.time.getTime())        state.time &#x3D; new Date(time2.setDate(state.time.getDate() + 1))        console.log(state.time) &#x2F;&#x2F; App.vue:38 Wed Nov 04 2020 10:09:02 GMT+0800 (中国标准时间)    &#125;    return &#123;state,changeVal&#125;     &#125;&#125;&lt;&#x2F;script&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h3 id="ref的理解"><a href="#ref的理解" class="headerlink" title="ref的理解"></a>ref的理解</h3><blockquote><p>Takes an inner value and returns a reactive and mutable ref object. The ref object has a single property .value that points to the inner value.</p></blockquote><ul><li>从官网上的解释我们可以知道，ref也是用来实现响应式数据的，它的参数不是对象，是简单值的监听</li><li>ref的本质仍然是返回reactive，只不过在系统会自动将我们传的参数，改写成以下这种形式<br>reactive({<br> value: xx<br>})</li><li>ref的注意点：<br>在js中只能通过value的形式更新或者获取值<br>在vue的template中，可以直接使用变量获取，系统会默认加上value属性</li></ul><p>  <strong>案例</strong><br>  <pre class="line-numbers language-none"><code class="language-none">&lt;template&gt;    &lt;div&gt;        &lt;p&gt;&#123;&#123;count&#125;&#125;&lt;&#x2F;p&gt;        &lt;button @click&#x3D;&quot;changeVal&quot;&gt;按钮&lt;&#x2F;button&gt;    &lt;&#x2F;div&gt;&lt;&#x2F;template&gt;&lt;script&gt;import &#123;ref&#125; from &#39;vue&#39;export default &#123;    name:&#39;App&#39;,    setup()&#123;        let count &#x3D; ref(2)        console.log(count) &#x2F;&#x2F;RefImpl &#123;_rawValue: 2, _shallow: false, __v_isRef: true, _value: 2&#125;        function changeVal() &#123;            &#x2F;&#x2F; count 的本质是一个对象，直接将count赋值为3，是无法使视图改变的            &#x2F;&#x2F; count &#x3D; 3            &#x2F;&#x2F;  console.log(count) &#x2F;&#x2F; 3            count.value &#x3D; 3            console.log(count)             &#x2F;&#x2F; RefImpl &#123;_rawValue: 3, _shallow: false, __v_isRef: true, _value: 3        &#125;        return &#123;count,changeVal&#125;    &#125;&#125;&lt;&#x2F;script&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p><h3 id="ref和reactive的区别"><a href="#ref和reactive的区别" class="headerlink" title="ref和reactive的区别"></a>ref和reactive的区别</h3><ul><li><p>在template中使用的数据类型如果是ref类型，Vue会自动帮我们添加.value</p></li><li><p>在template中使用的数据类型如果是reactive类型，Vue不会自动帮我们添加.value</p></li><li><p>Vue是如何决定是否需要自动添加.value?<br>Vue在解析数据之前，会自动判断这个数据是ref类型还是reactive类型</p></li><li><p>Vue是根据什么属性判断的<br>通过当前数据的__v_ref属性判断的。这是vue的私有属性，如果这个属性存在且值为true，则当前数据是一个ref</p></li><li><p>Vue中提供了两个API，isReactive 和 isRef 来判断数据是ref还是reactive；</p><pre class="line-numbers language-none"><code class="language-none">let count &#x3D; ref(0)console.log(isRef(count)) &#x2F;&#x2F; trueconsole.log(isReactive(count)) &#x2F;&#x2F; false<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li></ul><h3 id="递归监听和非递归监听"><a href="#递归监听和非递归监听" class="headerlink" title="递归监听和非递归监听"></a>递归监听和非递归监听</h3><ul><li>默认情况下，ref 和 reactive都是递归监听的。如果数据量大且结构复杂的话，会耗费性能，<br>所以，vue3引入了shallowReactive 和 shallowRef 两个API</li><li>先举个例子说一下，ref和reactive 是如何进行递归监听的</li></ul><p>  <strong>案例一</strong><br>  下面的实例告诉我们reactive通过递归监听，每次输出的结果都是一个Proxy对象；在数据量很大的情况下这种会耗费性能<br>  <pre class="line-numbers language-none"><code class="language-none">&lt;template&gt;    &lt;div&gt;        &lt;p&gt;&#123;&#123;state.a&#125;&#125;&lt;&#x2F;p&gt;        &lt;p&gt;&#123;&#123;state.b.c&#125;&#125;&lt;&#x2F;p&gt;        &lt;p&gt;&#123;&#123;state.b.d.s&#125;&#125;&lt;&#x2F;p&gt;        &lt;button @click&#x3D;&quot;changeVal&quot;&gt;按钮&lt;&#x2F;button&gt;    &lt;&#x2F;div&gt;&lt;&#x2F;template&gt;&lt;script&gt;import &#123; reactive &#125; from &#39;vue&#39;export default &#123;    name:&#39;App&#39;,    setup()&#123;        let state &#x3D; reactive(&#123;            a:&#39;a&#39;,            b:&#123;                c:&#39;c&#39;,                d:&#123;                    s:&#39;d&#39;                &#125;            &#125;        &#125;)        function changeVal() &#123;            state.a &#x3D; &#39;1&#39;            state.b.c &#x3D; &#39;2&#39;            state.b.d.s &#x3D; &#39;3&#39;            console.log(state) &#x2F;&#x2F; Proxy &#123;a: &quot;1&quot;, b: &#123;…&#125;&#125;            console.log(state.b) &#x2F;&#x2F; Proxy &#123;c: &quot;2&quot;, d: &#123;…&#125;&#125;            console.log(state.b.d) &#x2F;&#x2F; Proxy &#123;s: &quot;3&quot;&#125;        &#125;        return &#123;state , changeVal&#125;    &#125;&#125;&lt;&#x2F;script&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p><p>  <strong>案例二 shallowReactive</strong><br>  <pre class="line-numbers language-none"><code class="language-none">&lt;template&gt;    &lt;div&gt;        &lt;p&gt;&#123;&#123;state.a&#125;&#125;&lt;&#x2F;p&gt;        &lt;p&gt;&#123;&#123;state.b.c&#125;&#125;&lt;&#x2F;p&gt;        &lt;p&gt;&#123;&#123;state.b.d.s&#125;&#125;&lt;&#x2F;p&gt;        &lt;button @click&#x3D;&quot;changeVal&quot;&gt;按钮&lt;&#x2F;button&gt;    &lt;&#x2F;div&gt;&lt;&#x2F;template&gt;&lt;script&gt;import &#123; shallowReactive &#125; from &#39;vue&#39;export default &#123;    name:&#39;App&#39;,    setup()&#123;    let state &#x3D; shallowReactive(&#123;            a:&#39;a&#39;,            b:&#123;                c:&#39;c&#39;,                d:&#123;                    s:&#39;d&#39;                &#125;            &#125;        &#125;)        function changeVal() &#123;            &#x2F;&#x2F;state.a &#x3D; 1            console.log(state) &#x2F;&#x2F;  Proxy &#123;a: 1, b: &#123;…&#125;&#125;            console.log(state.b) &#x2F;&#x2F; &#123;c: 2, d: &#123;…&#125;&#125;            console.log(state.b.d) &#x2F;&#x2F;  &#123;s: 3&#125;            &#x2F;&#x2F; 这种情况下只有state是Proxy的对象            &#x2F;&#x2F; 如果我不修改state.a,直接修改state.b.c,会不会监听到变化，视图随之改变呢？            state.b.c &#x3D; 2            &#x2F;&#x2F; 可以自己写一个demo试一下。结果是不会改变。                &#125;        return &#123;state , changeVal&#125;      &#125;&#125;&lt;&#x2F;script&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p><p>  <strong>案例三 shallowRef 和 triggerRef</strong><br>  <pre class="line-numbers language-none"><code class="language-none">let state &#x3D; shallowRef(&#123;  a:&#39;a&#39;,  b:&#123;      c:&#39;c&#39;,      d:&#123;          s:&#39;d&#39;      &#125;  &#125;&#125;)function changeVal() &#123;    &#x2F;&#x2F; 这样直接改值的话，视图不会更新的     state.value.a &#x3D; 2     &#x2F;&#x2F; 正确方式：     state.value &#x3D; &#123;         a:1,         b:&#123;             c:2,             d:&#123;                 s:3             &#125;         &#125;     &#125;    &#x2F;&#x2F; 如果只改动state.b.d中的值，要如何实现呢？    &#x2F;&#x2F; 这里引入了triggerRef的API    &#x2F;**     state.value.b.c &#x3D; 5    triggerRef(state)     **&#x2F;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p><h2 id="附录-（vue-PatchFlags-标识符）"><a href="#附录-（vue-PatchFlags-标识符）" class="headerlink" title="附录 （vue PatchFlags 标识符）"></a>附录 （vue PatchFlags 标识符）</h2><pre class="line-numbers language-none"><code class="language-none">export const enum PatchFlags &#123;  &#x2F;&#x2F; 动态文字内容  TEXT &#x3D; 1,  &#x2F;&#x2F; 动态 class  CLASS &#x3D; 1 &lt;&lt; 1, &#x2F;&#x2F; 2  &#x2F;&#x2F; 动态样式  STYLE &#x3D; 1 &lt;&lt; 2, &#x2F;&#x2F; 4  &#x2F;&#x2F; 动态 props  PROPS &#x3D; 1 &lt;&lt; 3, &#x2F;&#x2F; 8  &#x2F;&#x2F; 有动态的key，也就是说props对象的key不是确定的  FULL_PROPS &#x3D; 1 &lt;&lt; 4, &#x2F;&#x2F; 16  &#x2F;&#x2F; 合并事件  HYDRATE_EVENTS &#x3D; 1 &lt;&lt; 5, &#x2F;&#x2F; 32  &#x2F;&#x2F; children 顺序确定的 fragment  STABLE_FRAGMENT &#x3D; 1 &lt;&lt; 6, &#x2F;&#x2F; 64  &#x2F;&#x2F; children中有带有key的节点的fragment  KEYED_FRAGMENT &#x3D; 1 &lt;&lt; 7, &#x2F;&#x2F; 128  &#x2F;&#x2F; 没有key的children的fragment  UNKEYED_FRAGMENT &#x3D; 1 &lt;&lt; 8, &#x2F;&#x2F; 256  &#x2F;&#x2F; 只有非props需要patch的，比如&#96;ref&#96;  NEED_PATCH &#x3D; 1 &lt;&lt; 9, &#x2F;&#x2F; 512  &#x2F;&#x2F; 动态的插槽  DYNAMIC_SLOTS &#x3D; 1 &lt;&lt; 10, &#x2F;&#x2F; 1024  &#x2F;&#x2F; SPECIAL FLAGS -------------------------------------------------------------  &#x2F;&#x2F; 以下是特殊的flag，不会在优化中被用到，是内置的特殊flag  &#x2F;&#x2F; 表示他是静态节点，他的内容永远不会改变，对于hydrate的过程中，不会需要再对其子节点进行diff  HOISTED &#x3D; -1,  &#x2F;&#x2F; 用来表示一个节点的diff应该结束  BAIL &#x3D; -2,&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>搭建个人博客（hexo框架为例）</title>
      <link href="2020/10/30/build-blog/"/>
      <url>2020/10/30/build-blog/</url>
      
        <content type="html"><![CDATA[<p>欢迎大家访问我的博客<a href="https://github.com/dreamITGirl">dreamITGirl</a>，不要吝啬你们的小星星，点个star～ 有问题的话，你可以将问题在 <a href="https://github.com/dreamITGirl/dreamITGirl.github.io/issues">GitHub</a>问我.<br>这篇文章适合有前端基础及会使用git及gitHub的人阅读.<a href="https://hexo.bootcss.com/">hexo</a>是快速、简洁且高效的博客框架，适合新手。如果平时用vue开发的话，可以使用<a href="https://www.vuepress.cn/">vuePress</a>;如果使用react开发的话，可使用<a href="https://github.com/destinytaoer/gatsby-start">Gatsby</a>；如果喜欢自己造轮子的话，也可以自己从0搭建。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h3 id="安装博客框架Hexo"><a href="#安装博客框架Hexo" class="headerlink" title="安装博客框架Hexo"></a>安装博客框架Hexo</h3><p>代码中的blog指的是项目的名称，可以更换成自己的项目名称</p><pre class="line-numbers language-none"><code class="language-none">npm install hexo-cli -g hexo init blogcd blognpm installhexo server<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="配置主题"><a href="#配置主题" class="headerlink" title="配置主题"></a>配置主题</h3><p>如果喜欢系统默认的博客主题的话，可以不修改主题；如果不喜欢的话，可以去<a href="https://github.com/">github</a>官网中<br>搜索<strong>hexo-theme</strong>，选择自己喜欢的主题；<br>这里以<a href="https://github.com/blinkfox/hexo-theme-matery/blob/develop/README_CN.md">blinkfox/hexo-theme-matery</a>为例</p><pre class="line-numbers language-none"><code class="language-none">git clone https:&#x2F;&#x2F;github.com&#x2F;blinkfox&#x2F;hexo-theme-matery.git <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol start="2"><li>将克隆到本地的主题移动到hexo根目录themes目录中，将博客中的其他主题删掉</li><li>删除下载的主题中的.git目录，这样做的目的是为了让下载后的主题和我们的博客放在同一个git地址下</li><li>修改Hexo根目录下的_config.yml中的theme，将它改成 hexo-theme-matery</li></ol><h3 id="Hexo根目录下的-config-yml"><a href="#Hexo根目录下的-config-yml" class="headerlink" title="Hexo根目录下的_config.yml"></a>Hexo根目录下的_config.yml</h3><p>Hexo根目录下的_config.yml中可以设置博客站点的标题、副标题、描述、作者、语言等</p><h2 id="上传到github"><a href="#上传到github" class="headerlink" title="上传到github"></a>上传到github</h2><h3 id="创建库"><a href="#创建库" class="headerlink" title="创建库"></a>创建库</h3><ol><li><p>命名博客的方式</p><p> 命名方式一：https://[username].github.io<br> 仓库名必须是[username].github.io,将打包的版本放在master<br> 命名方式二: https://[username].github.io/[repo]<br> 这种方式可以自定义库名，打包的版本放在gh-pages(对应的库名)<br> 第一种方式更适合用来部署博客，第二种方式更适合部署开源项目或者作品展示等</p></li><li><p>创建库<br> 创建库的方式如图所示</p> <a href="/2020/10/30/build-blog/build1.png" title="点击查看图片">点击查看图片</a><p> 创建成功后，我们需要将本地的代码传到我们创建的库，我习惯使用命令行的方式，把命令写在下面，需要的话自取</p> <pre class="line-numbers language-none"><code class="language-none">git init git add remote &#39;创建成功后提示的路径&#39;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p> 这两行代码是初始化git项目，并给项目添加远程仓库<br> 在使用git管理代码之前，先安装hexo-deployer-git依赖，这个库会帮助我们将生成好的代码放到具体的分支上，<br> 安装好后，打开<strong>_config.yml</strong>文件，找到deploy,设置对应内容</p> <pre class="line-numbers language-none"><code class="language-none">deploy:    type: git    repo: https:&#x2F;&#x2F;github.com&#x2F;dreamITGirl&#x2F;dreamITGirl.github.io    branch: master<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>接下来运行</p> <pre class="line-numbers language-none"><code class="language-none">npm run deploy &#x2F;&#x2F; 或者运行hexo deploy<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p> 部署代码；代码提交完成后，我们就可以在远程仓库中看到我们提交的代码了。我们提交的master的代码就是打包后public目录下的文件。<br> 然后找到这个远程库的setting，找到GitHub Pages,这里面显示了我们的站点已经部署到了我们命名的仓库地址上了，点击就可以看到我们的博客了<br> 到这里为止，我们就完成了一个最基本的博客的部署</p><h3 id="自动化部署"><a href="#自动化部署" class="headerlink" title="自动化部署"></a>自动化部署</h3><p> 在做自动化部署之前，我们需要将我们的源代码提交到远程仓库,master分支现在已经被占用了，我们需要将源代码提交到另一个分支上</p> <pre class="line-numbers language-none"><code class="language-none">git add .git commit -m &#39;提交源代码&#39;git branch my-blog &#x2F;&#x2F; my-blog是分支名称git push --set-upstream origin my-blog<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p> 我们也可以在仓库首页放上我们的博客地址，便于访问</p><p> 接下来就是自动化部署了，这里用到github中的actions,我们这里会实现项目的代码部署和自动打包</p><ol><li><p>在根目录创建.github文件夹及子文件夹workflows</p></li><li><p>创建deploy.yml文件</p></li><li><p>deploy.yml代码如下</p><pre class="line-numbers language-none"><code class="language-none">name: Build and Deployon: [push]jobs:  build-and-deploy:    runs-on: ubuntu-latest    steps:      - name: Checkout 🛎️        uses: actions&#x2F;checkout@v2 # If you&#39;re using actions&#x2F;checkout@v2 you must set persist-credentials to false in most cases for the deployment to work correctly.        with:          persist-credentials: false      - name: Install and Build 🔧 # This example project is built using npm and outputs the result to the &#39;build&#39; folder. Replace with the commands required to build your project, or remove this step entirely if your site is pre-built.        run: |          npm install          npm run build        env:          CI: false      - name: Deploy 🚀        uses: JamesIves&#x2F;github-pages-deploy-action@releases&#x2F;v3        with:          GITHUB_TOKEN: $&#123;&#123; secrets.GITHUB_TOKEN &#125;&#125;          BRANCH: master # The branch the action should deploy to.          FOLDER: public # The folder the action should deploy.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们将代码设置好之后，将源码提交到刚才创建的分支上后，代码就可以自动打包，生成新的版本</p></li></ol></li></ol>]]></content>
      
      
      <categories>
          
          <category> 框架学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
